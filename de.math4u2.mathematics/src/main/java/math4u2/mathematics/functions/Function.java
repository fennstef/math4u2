/* Generated by Together */

package math4u2.mathematics.functions;

import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import math4u2.controller.Broker;
import math4u2.controller.BrokerException;
import math4u2.controller.MathObject;
import math4u2.controller.reference.AbstractPathStep;
import math4u2.controller.reference.CreatePathException;
import math4u2.controller.reference.CreatesPath;
import math4u2.controller.reference.MethodContext;
import math4u2.controller.reference.PathStep;
import math4u2.controller.relation.ObjectNotInRelationException;
import math4u2.controller.relation.RelationContainer;
import math4u2.controller.relation.RelationFactory;
import math4u2.controller.relation.RelationInterface;
import math4u2.mathematics.results.DoubleResult;
import math4u2.mathematics.results.ScalarDoubleResult;
import math4u2.mathematics.standardfunctions.BracketsFunction;
import math4u2.mathematics.termnodes.TermNode;
import math4u2.mathematics.types.ScalarType;
import math4u2.util.exception.ExceptionManager;
import math4u2.util.exception.NotImplementedException;
import math4u2.util.io.file.FileUtils;
import math4u2.util.io.file.GenericFileFilter;
import math4u2.util.io.file.Visitor;
import math4u2.view.gui.listview.ViewFactoryInterface;

/**
 * 
 * <p>
 * Funktionen
 * </p>
 * <p>
 * Beschreibt eine Funktion einer bestimmten Stelligkeit. Eine null-stellige
 * Funktion steht für einen Parameter. Funktionen werden über ihren Namen
 * (String) angesprochen und verwaltet.
 * </p>
 * <p>
 * Copyright (c) 2002
 * </p>
 * <p>
 * Organisation: FHA
 * </p>
 * 
 * @author Weiss
 * @version 1.0
 */
public abstract class Function implements MathObject, CreatesPath {

	/***************************************************************************
	 * Dieser Name ist der Schlüssel, über den die Funktion durch einen Broker
	 * verwaltet wird. In der Regel ist das auch der Name, mit dem der Benutzer
	 * die Funktion anspricht. Ausnahmen sind Funktionen wie Summe, Prokukt,
	 * ..., die der Benutzer ueber ihre Operatorschreibweise anspricht.
	 */
	protected String name;

	/***************************************************************************
	 * Beziehungs-Container der Funktion
	 */
	protected RelationContainer relationContainer;

	private static ViewFactoryInterface viewFactory;

	public Function() {
		this.relationContainer = new RelationContainer(this);
	} // Kontruktor

	public ViewFactoryInterface getViewFactory() {
		return viewFactory;
	}

	/**
	 * Muss von Funktionen, die besondere Anforderung an die Argumentterme
	 * stellen, ueberschieben werden. Besondere Anforderungen sind z.B. das
	 * Argument arguments[0] darf keine Variable enthalten.
	 * 
	 * @param arguments
	 * @return
	 */
	public void reportArgumentConflict(TermNode[] arguments)
			throws MathException {
	}

	/**
	 * Liefert den Typ, welches das Ergebnis von eval() in Abhängigkeit von den
	 * Ergebnistypen der Argumente hat.
	 */
	public abstract Class getResultType(Class[] argTypes);

	/**
	 * Liefert das Interface, welches der Wert der Variable an der Stelle pos
	 * haben muss. Die Stellen werden von 0 beginnend gezaehlt.
	 */
	public abstract Class getVariableType(int pos) throws MathException;

	/***************************************************************************
	 * Die Variablennamen dienen zur Darstellung der Funktion dem Benutzer
	 * gegenüber.
	 * 
	 * @return Array mir den Namen der Variablen.
	 */
	abstract String[] getVariableNames();

	/***************************************************************************
	 * Stelligkeit der Funktion, ein Wert aus 0,1,2,3,... . Funktionen mit der
	 * Stelligkeit 0 werden häufig auch als Parameter bezeichnet.
	 */
	public abstract int getArity();

	/***************************************************************************
	 * Berechnet den Wert der Funktion. Zunächst werden die Variablen der Reihe
	 * nach durch die Werte im Array args ersetzt, dann wird der Wert des
	 * Funktionsterms berechnet. Die Länge von args muss mit der Stelligkeit der
	 * Funtion (getArity()) übereinstimmen.
	 */
	public abstract Object eval(Object[] args) throws MathException;

	public Object shallowEval(Object[] args) throws MathException {
		return eval(args);
	}

	/**
	 * Spezialform von eval() für nullstellige Funktionen. Kann von abgeleiteten
	 * Klassen ueberschrieben werden, um in diesem haeufig auftretenden Fall
	 * eine optimale Performance zu erhalten.
	 */
	public Object eval() throws MathException {
		return eval(new Object[] {});
	}

	public double evalScalar() throws MathException {
		return ((ScalarDoubleResult) eval()).evalScalar();
	}

	public Object shallowEval() throws MathException, Exception {
		return shallowEval(new DoubleResult[] {});
	}

	/**
	 * Spezialform von eval() für einstellige Funktionen. Kann von abgeleiteten
	 * Klassen ueberschrieben werden, um in diesem haeufig auftretenden Fall
	 * eine optimale Performance zu erhalten.
	 */
	public Object eval(Object arg) throws MathException {
		return eval(new Object[] { arg });
	}

	private Object[] evalArguments;

	public Object shallowEval(Object arg) throws MathException, Exception {
		if (evalArguments == null || evalArguments.length != 1)
			evalArguments = new Object[1];
		evalArguments[0] = arg;
		return shallowEval(evalArguments);
	}

	/***************************************************************************
	 * Konstruiert aus den Argumenten und deren Ableitungen der aktuellen
	 * Funktion den Funktionsterm der Ableitung.
	 * 
	 * @param argumentTerms
	 *            Terme, die die aktuellen Argumente der Funktion darstellen
	 * @param derivedArgumentTerms
	 *            abgeleitete Argumentterme
	 * @param broker
	 *            zuständiger Broker
	 * @return Funktionsterm der Ableitungsfunktion
	 */
	public abstract TermNode buildDeriveTerm(TermNode[] argumentTerms,
			TermNode[] derivedArgumentTerms, Broker broker)
			throws MathException;

	/**
	 * Liefert die Funktion, die man erhält, wenn man die aktuelle Funktion nach
	 * der Variable an der Position derivePos ableitet.
	 * 
	 * @param derivePos
	 *            Position der Variable, nach der abgeleitet werden soll, die
	 *            erste Variable wird mit dem Wert 1 angesprochen.
	 * @param deriveOrder
	 *            Ordnung der Ableitung, bei dem Wert 0 wird die Funktion selbst
	 *            zurueckgegeben.
	 * @param broker
	 * @return Ableitungsfunktion
	 */
	public Function getDeriveFunction(int derivePos, int deriveOrder,
			Broker broker) throws MathException {
		throw new NotImplementedException();
	}

	/**
	 * Meldet alle Standardfunktionen (nullstellig, einstellig und zweistellig)
	 * beim Broker broker an.
	 * 
	 * @param broker
	 */
	public static void registerAll(final Broker broker) throws Exception {
		Visitor visitor = new Visitor() {
			public void visit(Object arg) {
				Function f;
				File cur = (File) arg;
				String fullClassName = "";
				do {
					fullClassName = cur.getName() + "." + fullClassName;
					cur = cur.getParentFile();
				} while (!cur.getName().equals("math4u2"));
				fullClassName = cur.getName() + "." + fullClassName.substring(0, fullClassName.length()-".class.".length());
				try {
					Class fncClass = Class.forName(fullClassName);
					f = (Function) (fncClass.getConstructors())[0]
							.newInstance(new Object[] {});
					if (f instanceof StandardFunction)
						broker.publishObject(f, (String) f.getKey());
				} catch (BrokerException e) {
					ExceptionManager.doError(e);
				} catch (ClassNotFoundException e) {
					ExceptionManager.doError(
							"Die Klasse wurde nicht gefunden (" + fullClassName
									+ ").", e);
				} catch (InstantiationException e) {
					ExceptionManager.doError(
							"Die Klasse konnte nicht instatiiert werden ("
									+ fullClassName + ").", e);
				} catch (IllegalAccessException e) {
					ExceptionManager.doError(
							"Es konnte nicht auf die Klasse zugegriffen werden ("
									+ fullClassName + ").", e);
				} catch (InvocationTargetException e) {
					ExceptionManager.doError(
							"Fehler bei der Ausführung aufgetreten (" + fullClassName
									+ ")", e);
				} catch (ObjectNotInRelationException e) {
					ExceptionManager.doError(
							"Fehler beim Registieren der Funktion aufgetreten ("
									+ fullClassName + ")", e);
				}
			}// visit
		};
		File stdFunctionsDir = new File(BracketsFunction.class.getClassLoader()
				.getResource("math4u2/mathematics/standardfunctions").toURI());
		FileUtils.traverseDir(stdFunctionsDir,
				new GenericFileFilter("*.class"), visitor);
	}// registerAll

	/**
	 * Verknüpt eine Funktion f mit seinen Beziehungspartnern (parts)
	 * 
	 * @param f
	 *            Funktion, die verknüpft werden soll
	 * @param parts
	 *            Liste von Funktionen, die Beziehungspartner sind
	 * @param regList
	 *            Liste von Objekten, die bei Problemen gelöscht wird (anonyme
	 *            Objekte)
	 * @param broker
	 */
	public static void register(MathObject f, List partsWithPath, List regList,
			Broker broker) throws BrokerException {
		// Überprüfung, ob alles in Ordnung ist
		if (!(f instanceof Function))
			throw new IllegalArgumentException("Das Objekt mit dem Schlüssel "
					+ f.getKey() + " muß eine Funktion sein. Ist aber "
					+ f.getClass());
		// for (Iterator iter = partsWithPath.iterator(); iter.hasNext();) {
		// MathObjectPath mop = (MathObjectPath)iter.next();
		// MathObject element = (MathObject)mop.getMathObject();
		// if (!(element instanceof Function))
		// throw new IllegalArgumentException(
		// "Das Objekt mit dem Schlüssel "
		// + element.getKey()
		// + " muß eine Funktion sein. Ist aber "
		// + element.getClass()
		// + ".");
		// } //for iter
		if (broker == null)
			throw new NullPointerException(
					"Der Broker ist null. Dies ist hier nicht erlaubt.");
		// Beziehungen und Objektliste erzeugen
		List relations = new LinkedList();
		List parts = new LinkedList();
		for (Iterator iter = partsWithPath.iterator(); iter.hasNext();) {
			MathObject element = (MathObject) iter.next();
			RelationInterface ri = null;

			if (regList.contains(element))
				ri = RelationFactory.getPart_Of_Relation();
			else
				ri = RelationFactory.getFunction_SubFunction_Relation();

			// ri.setCreationPath(element.getTermString().split("."));
			relations.add(ri);
			parts.add(element);
		} // for iter

		// Definieren
		broker.defineRelations(f, parts, relations, Broker.FIRST_OBJECT);
	} // register

	/**
	 * @see MathObject#setName(String)
	 */
	public void setName(String name) {
		this.name = name;
	} // setName

	/**
	 * Konstruiert aus dem Namen der Funktion und den Namen der Variablen eine
	 * Zeichenkette wie f(x) oder sin(x) oder skalarprodukt(x,y) .
	 * 
	 * @return
	 */
	public String getDefinitionHeader() {
		int arity = getArity();
		String typeString = "";
		String[] vars = getVariableNames();

		String s = name;
		if (name == null)
			s = RelationContainer.tryToGetFullName(this, "");

		for (int i = 0; i < arity; i++) {
			if (i != 0)
				typeString += ",";

			try {
				Class type = getVariableType(i);
				Method m = type.getMethod("getTypeString", new Class[0]);
				typeString += (String) m.invoke(null, new Object[0]);
			} catch (MathException e) {
				ExceptionManager.doError(
						"Fehler beim Erstellen des Funktionsheaders (" + name
								+ ")", e);
			} catch (NoSuchMethodException e) {
				ExceptionManager.doError(
						"Fehler beim Erstellen des Funktionsheaders (" + name
								+ ")", e);
			} catch (IllegalAccessException e) {
				ExceptionManager.doError(
						"Fehler beim Erstellen des Funktionsheaders (" + name
								+ ")", e);
			} catch (InvocationTargetException e) {
				ExceptionManager.doError(
						"Fehler beim Erstellen des Funktionsheaders (" + name
								+ ")", e);
			}

			typeString += vars[i];

		}// for i
		if (getArity() != 0)
			typeString = "(" + typeString + ")";
		return s + typeString;
	}// getDefinitionHeader

	/***************************************************************************
	 * Standardmethode zur Darstellung eines Funktionsaufrufs. Konstuiert z.B.
	 * für die cosinus-Funktion mit dem angegebenen Aktualparameter das Ergebnis
	 * "cos(x+sin(x))". Wird bei Infix-Funktionen ueberschrieben.
	 * 
	 * @param argStrings
	 *            Aktualparamter, z.B. "x+sin(x)"
	 * @return Darstellung des Funktionsaufrufs als String.
	 */
	public String buildTermString(String[] argStrings, String name) {
		if (this.name != null)
			name = this.name;
		if (getArity() == 0)
			return name;

		// else: Funktion mit Stelligkeit > 0
		String values = (argStrings.length == 1) ? "" : " ";
		for (int i = 0; i < argStrings.length; i++) {
			values += argStrings[i];
			if (argStrings.length - 1 != i)
				values += ", ";
		}
		return name + "(" + values + ")";
	} // buildTermString

	/***************************************************************************
	 * Standardmethode zur Darstellung eines Funktionsaufrufs. Konstuiert z.B.
	 * für die cosinus-Funktion mit dem angegebenen Aktualparameter das Ergebnis
	 * "cos(x+sin(x))". Wird bei Infix-Funktionen ueberschrieben.
	 * 
	 * @param argStrings
	 *            Aktualparamter, z.B. "x+sin(x)"
	 * @return Darstellung des Funktionsaufrufs als String.
	 */
	/*
	 * public String buildTermString(String[] argStrings){
	 * 
	 * if ( getArity() == 0 ) return name; // else: Funktion mit Stelligkeit > 0
	 * String values = " "; for(int i=0; i <argStrings.length;i++) { values +=
	 * argStrings[i]; if(argStrings.length - 1 != i) values += ", "; } return
	 * name + "(" + values + ")"; }
	 */// buildTermString
	/***************************************************************************
	 * Funktionen werden über ihre Namen verwaltet. getKey() liefert einen
	 * String, der den Namen der Funktion enthält.
	 */
	public Object getKey() {
		return name;
	} // getKey

	/***************************************************************************
	 * Entscheidet, ob eine Funktionsdefinition durch eine andere ersetzt werden
	 * kann. Ist bei StandardFunction und UserFunction unterschiedlich
	 * implementiert.
	 */
	public abstract boolean testSubstitution(MathObject oldObject,
			Set oldAggregateSet);

	/***************************************************************************
	 * Eine Funktion kann im Broker gelöscht werden, wenn sie in keinem Aggregat
	 * vorkommt. testDelete() liefert also genau dann true, wenn das Set
	 * aggregateSet leer ist.
	 */
	public boolean testDelete() {
		return true;
	} // testDelete

	public void prepareDelete() {
	};

	/***************************************************************************
	 * Standard-Reaktion auf die Tatsache, dass sich einer der Bestandteile der
	 * Funktionsdefinition geändert hat: Keine.
	 */
	public void renew(MathObject source) {
	}

	/**
	 * @see math4u2.controller.MathObject#getRelationContainer()
	 */
	public RelationContainer getRelationContainer() {
		return relationContainer;
	} // getRelationContainer

	/***************************************************************************
	 * Zwei Funktionen werden als gleich betrachtet, wenn ihre Schlüssel,
	 * letztlich also ihre Namen gleich sind.
	 */
	// public boolean equals(Object anotherObject) {
	// return this.getKey().equals(((MathObject)anotherObject).getKey());
	// } // equals
	public TermNode simplify(TermNode oldTerm, TermNode[] arguments,
			Broker broker) throws MathException {
		return oldTerm;
	}

	public TermNode evalNum(TermNode oldTerm, TermNode[] arguments,
			Broker broker) throws Exception {
		return oldTerm;
	}

	/**
	 * Diese Methoden werden von außen aufgerufen z.B. sin.funktion.stellen usw.
	 * 
	 * Anfang --------------------------------------------------------
	 */

	public Object operator_stellen(Object[] value) {
		return new ScalarDoubleResult(getArity());
	}// operator_stellen

	public Class returnType_stellen(MethodContext mc) {
		return ScalarType.class;
	}// returnType_stellen

	// --------------------------------------

	public Object operator_funktion(Object[] value) {
		return this;
	}// operator_funktion

	public Class returnType_funktion(MethodContext mc) {
		return this.getClass();
	}// returnType_funktion

	// --------------------------------------

	public Class returnType_derive(MethodContext mc) {
		return this.getClass();
	}// returnType_derive

	public Object operator_derive(Object[] value) throws MathException {
		return this.getDeriveFunction(1, 1, null);
	}

	// --------------------------------------

	public Object operator_calceval(Object[] value) throws MathException {
		return eval(value);
	}// operator_calceval

	public Object operator_eval(Object[] value) throws MathException {
		return eval(value);
	}// operator_calceval

	public Class returnType_calceval(MethodContext mc) {
		// ab hier Funktionstypen z.B. Vektor + Vektor usw.
		TermNode[] args = mc.getArgs();
		Class[] argClass = new Class[args.length];
		for (int i = 0; i < args.length; i++) {
			argClass[i] = args[i].getResultType();
		} // for i
		return getResultType(argClass);
	}// class returnType_calceval

	public Class returnType_eval(MethodContext mc) {

		return returnType_calceval(mc);
	}// class returnType_eval

	/**
	 * Ende ----------------------------------------------------------
	 */

	public PathStep createPathStep(List methods) throws CreatePathException {
		// Methoden Überprüfung und Umbau
		MethodContext mc = null;
		if (!methods.isEmpty()) {
			// falls Methode da ist
			mc = (MethodContext) methods.get(0);
		} else {
			// andernfalls eine Eval-Methode erzeugen und speichern
			mc = new MethodContext("calceval", new TermNode[] {});
			methods.add(mc);
		} // else

		if (!mc.getMethodName().equals("funktion")
				&& !mc.getMethodName().equals("eval")
				&& !mc.getMethodName().equals("calceval") && (getArity() == 0)) {
			// wenn die nächste Anweisung nicht "funktion" oder "eval" ist,
			// dann wird die Methode "eval" vorangestellt
			mc = new MethodContext("eval", new TermNode[0]);
			methods.add(0, mc);
		} // else

		// Eigentlicher Methoden aufbau
		mc = (MethodContext) methods.get(0);
		methods.remove(0);
		try {
			if ("calceval".equals(mc.getMethodName())
					&& getArity() != mc.getArgs().length) {
				throw new CreatePathException("Die Stelligkeit der Funktion '"
						+ name + "' ist ungültig." + "\nerlaubte Stelligkeit: "
						+ getArity() + "\nbenutzte Stelligkeit: "
						+ mc.getArgs().length);
			}
			;

			this.reportArgumentConflict(mc.getArgs());

			// Methode erzeugen
			Method m = this.getClass().getMethod(
					"operator_" + mc.getMethodName(),
					new Class[] { Object[].class });

			// Step erzeugen
			// es ist noch nicht der nächste Schritt eingtragen worden
			PathStep ps = AbstractPathStep.createStep(this, mc.getMethodName(),
					m, mc.getArgs());

			// falls keine weiteren Methoden folgen, aufhören
			if (methods.isEmpty())
				return ps;

			// nächstes Dummy-Objekt ermitteln
			Object nextObject;
			Class resultType = getReturnType(mc);

			nextObject = computeDummyObject(resultType);

			// nächsten Schritt erzeugen lassen und eintragen
			PathStep nextStep = ((CreatesPath) nextObject)
					.createPathStep(methods);
			ps.setNextStep(nextStep);
			return ps;
		} catch (NoSuchMethodException e) {
			throw new CreatePathException(
					"Fehler bei der Suche nach der Methode "
							+ mc.getMethodName(), e);
		} catch (CreatePathException e) {
			throw e;
		} catch (MathException e) {
			throw new CreatePathException(e);
		} catch (Throwable e) {
			throw new CreatePathException(
					"Fehler bei der Initialisierung der Methode "
							+ mc.getMethodName(), e);
		}
	} // createPathStep

	public Object computeDummyObject(Class resultType)
			throws SecurityException, NoSuchMethodException,
			IllegalArgumentException, IllegalAccessException,
			InvocationTargetException, MathException {
		// die Rückgabeklasse nach einen DummyObject fragen
		if (this.getClass() == resultType)
			return this;
		Method dummyGetMethode = resultType.getMethod("getDummyObject",
				new Class[] {});
		return dummyGetMethode.invoke(null, new Object[] {});
	}// computeDummyObject

	public Class getReturnType(PathStep nextStep) {
		MethodContext mc;
		if (nextStep == null)
			mc = new MethodContext("eval");
		else
			mc = nextStep.getMethodContext();
		return getReturnType(mc);
	} // getReturnType

	public Class getReturnType(MethodContext mc) {
		try {
			Method m = this.getClass().getMethod(
					"returnType_" + mc.getMethodName(),
					new Class[] { MethodContext.class });
			return (Class) m.invoke(this, new Object[] { mc });
		} catch (Exception e) {
			ExceptionManager.doError(
					"Fehler bei der Ermittlung des Rückgabetyps", e);
			throw new RuntimeException(e);
		}// catch
	}// getReturnType

	public static Object getDummyObject() {
		return new UserFunction(null, null, null, null);
	}// getDummyObject

	public String getName() {
		return name;
	}// getName
} // Function
