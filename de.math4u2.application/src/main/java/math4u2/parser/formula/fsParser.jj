/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:\daten\math4u\math4u2\math4u2\parser\formula\fsParser.jj */
/*@egen*//*options {
	MULTI=true;
    NODE_PACKAGE= "math4u2.parser.formula.parserNodes";
    STATIC = false;
	OUTPUT_DIRECTORY = "math4u2\\parser\\formula";
}*/


PARSER_BEGIN(fsParser)

package math4u2.parser.formula;

import java.io.StringReader;
import java.util.*;
import math4u2.parser.formula.parserNodes.*;
import math4u2.controller.*;
import math4u2.exercises.EParser;

public class fsParser/*@bgen(jjtree)*/implements fsParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTfsParserState jjtree = new JJTfsParserState();

/*@egen*/
	private Broker broker;
    private String formula;
    private Map modifierMap;
    public static void main(String args[]) {
    	try {
            Node node=fsParser.parseFormula("a(x)_3_1_2(y)_2(z)(w)",null,null);
            System.out.println(node.toString());
            SimpleNode.treeTraversal(node);
        } catch (ParseException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public void setModifierMap(Map modifierMap) {
    	if(modifierMap==null){
    		this.modifierMap= new HashMap(1);
    	}else{
    		this.modifierMap= new HashMap(modifierMap);
    	}
    }
    
    public static Node parseFormula(String formula, Map modifierMap, Broker broker)throws ParseException{
        fsParser fsp= new fsParser(new StringReader(formula));
            fsp.formula= formula;
            fsp.setModifierMap(modifierMap);
            fsp.broker = broker;
        try{
            return fsp.Start();
        }catch(ParseException pe){
            throw new ParseException("Fehler bei Formel: "+formula+"\n"+pe.getMessage());
        }
    }

    public String getFormulaString(){
        return formula;
    }
        
    public Map getModifierMap() {
        return modifierMap;
    }

    public Node parse(Broker broker) throws ParseException{
        this.broker=broker;
        return Start();
    }
}

PARSER_END(fsParser)

SKIP :
{
	" " 
	|
	"\t" 
	|
	"\n" 
	|
	"\r" 
	|
	< 
		"//"
		( ~[ "\n", "\r" ] )*
		( "\n" | "\r" | "\r\n" )
	>
	|
	< 
		"/*"
		( ~[ "*" ] )*
		"*"
		(
			~[ "/" ]
			( ~[ "*" ] )*
			"*"
		)*
		"/"
	>
}

TOKEN :
/*INFIX_OPERATORS*/

{
	<RELATIONSYMBOL : 
		(  "="  | "!=" | "<=" | ">=" )
		|
		<ARROW>
		|
		<REL_STRING_INFIX>
	>
	|
	<LT:
		"$lt"|"<"
	>
	|
	<GT:
		"$gt"|">"
	>
	|
	<#ARROW : 
		"$"
		( "larr" | "rarr" | "uarr" | "darr" | "harr" | "lArr" | "rArr" | "uArr" | "dArr" | "hArr" )
	>
	|
	<#REL_STRING_INFIX : 
		"$"
		(
			"ne"
			|
			"equiv"
			|
			"le"
			|
			"ge"
			|
			"sub"
			|
			"sup"
			|
			"nsub"
			|
			"supe"
			|
			"perp"
			|
			"isin"
			|
			"notin"
			|
			"ni"
			|
			"prop"
			|
			"sim"
			|
			"cong"
			|
			"asymp"
			|
			"and"
			|
			"or"
			|
			"cap"
			|
			"cup"
		)
	>
	|
	<ADDITIONSYMBOL : 
		[ "+", "-" ]
		|
		"+-"
		|
		<ADD_STRING>
	>
	|
	<#ADD_STRING : 
		"$"
		( "plusmn" | "oplus" )
	>
	|
	<MULTIPLICATIONSYMBOL : 
		<MULT >
		|
		<MULT_STRING>
	>
	|
	<#MULT : 
		"*"
		|
		"<*>"
	>
	|
	<#MULT_STRING : 
		"$otimes"
		|
		"$sdot"
		|
		"$mdot"
		|
		"$sp"
	>
	|
	<DIVIDE : 
		"/"
	>
}

TOKEN :
/* POST_PREFIX_OPERATORS */

{
	<POSTFIX : 
		"%"
		|
		"!"
	>
	|
	<STRING_PREFIX : 
		"$"
		( "not" | "ang" )
	>
}

TOKEN :
/* SPECIALS */

{
	<FUNCTION_PREFIX:
		"$f"
		("d"|"h"|"b")
	>
	|
	<NABLA : 
		"$nabla"
	>
	|
	<VOIDELEMENT:
		"$void"
	>
	|
	<DOTS :
		"$dots"
		|
		"$hdots"
		|
		"$vdots"
		|
		"$ddots"
		|
		"$nddots"
	>
	
}

TOKEN :
/* FUNCTIONS */

{
	<ROOT : 
		"root"
	>
	|
	<SQRT : 
		"sqrt"
	>
	|
	<LIM:
		"lim"
		|
		"lim+"
		|
		"lim-"
	>
	|
	<SUM : 
		"sum"
	>
	|
	<INT : 
		"int"
	>
	|
	<PROD : 
		"prod"
	>
	|
	<DERIVE : 
		"derive"
	>
	|
	<PDERIVE : 
		"pderive"
	>
	|
	<EXIST : 
		"exist"
	>
	|
	<FORALL : 
		"forall"
	>
	|
	<VARS :
		"vars"
	>
	|
	<MATHFUNCTION : 
		"sin"
		|
		"cos"
		|
		"tan"
		|
		"arcsin"
		|
		"arccos"
		|
		"arctan"
		|
		"ln"
		|
		"lg"
	>
	|
	<LOG : 
		"log"
	>
	|
	<FAC : 
		"fac"
	>
	|
	<EXPO : 
		"exp"
	>
	|
	<POW:
		"pow"
	>
	|
	<INVERSE:
		"inverse"
	>
	|
	<TRANSPOSE:
		"transpose"
	>
	|
	<VECMATH : 
		<MATRIX>
		|
		<VECTOR>
		|
		<DUALVEKTOR>
	>
	|
	<#MATRIX : 
		"matrix"
	>
	|
	<#VECTOR : 
		"vektor"
	>
	|
	<#DUALVEKTOR : 
		"dualvektor"
	>
	|
	<VECMATHSYMBOL:
		<LT> ( <VECMATH> ) <GT>
	>
	|
	<UNDEFVECTOR : 
		<LT> ("vektor(" | "dualvektor(")
	>
	|
	<UNDEFMATRIX : 
		<LT> "matrix("
	>
}

TOKEN :
/* LITERALS */

{
	<FLOAT_LITERAL : 
		<INTEGER_LITERAL>
		"."
		<INTEGER_LITERAL>
	>
	|
	<INTEGER_LITERAL : 
		<DIGIT>
		( <DIGIT> )*
	>
	|
	<#DIGIT : 
		[ "0"-"9" ]
		( [ "0"-"9" ] )*
	>
	|
	<ENUMBER:
		<INTEGER_LITERAL>("."<INTEGER_LITERAL>)?("E"|"e")("-")?<INTEGER_LITERAL>
	>
	|
	<INFIN : 
		"$infin"
	>
	|
	<EULER : 
		"e"
	>
	|
	<PI : 
		"$pi"
	>
	|
	<STRUCTURE:
		<INTEGER_LITERAL><IDENTIFIER>
	>
}

TOKEN :
/* SYMBOLS */

{
	<SYMBOL : 
		<GR_LETTER_UC>
	>
	|
	<#GR_LETTER_LC : 
		
		(
			"fnof"
			|
			"alpha"
			|
			"beta"
			|
			"gamma"
			|
			"delta"
			|
			"epsilon"
			|
			"zeta"
			|
			"eta"
			|
			"theta"
			|
			"iota"
			|
			"kappa"
			|
			"lambda"
			|
			"mu"
			|
			"nu"
			|
			"xi"
			|
			"sigma"
			|
			"tau"
			|
			"upsilon"
			|
			"phi"
			|
			"chi"
			|
			"psi"
			|
			"omega"
		)
	>
	|
	<#GR_LETTER_UC : 
		
		(
			"Alpha"
			|
			"Beta"
			|
			"Gamma"
			|
			"Delta"
			|
			"Theta"
			|
			"Lambda"
			|
			"Xi"
			|
			"Sigma"
			|
			"Upsilon"
			|
			"Omicron"
			|
			"Phi"
			|
			"Psi"
			|
			"Omega"
		)
	>
}

TOKEN :
/* IDENTIFIERS */

{
	< IDENTIFIER : 
		<LETTER>
		( <LETTER> | <DIGIT> )*
	>
	|
	< #LETTER : 
		[ "a"-"z", "A"-"Z" ]
	>
}

ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	Expression()
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{

		return jjtn000;

	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

/*
 * Ein Ausdruck kann sein
 * - Definition wie f(x):=
 * - Relation wie x+3 = 2*y - 4
 */
void Expression()       : {}
{
	LOOKAHEAD(Definition())
	Definition() 
	|
	RelationExpression() 
}

/*
 * eine Definition ist gekennzeichnet durch ein ":="
 */
void Definition()       : {}
{/*@bgen(jjtree) #NormalExpression(> 1) */
        {
          ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		FunctionExpression() ":=" RelationExpression()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  jjtc001 = false;
                }
/*@egen*/ 
		{
			jjtn001.setName(":=");
		}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

/*
 * eine Relation besteht aus:
 * - min. zwei Ausdr\u00fccken mit Operatoren deren Bindungsst\u00e4rke nicht h\u00f6her als die der Addition
 * - zwischen zwei Ausdr\u00fccken steht ein Relationszeichen: <, >, =, ...
 */
void RelationExpression()       : {

	Token symbol;

}
{
	(
		AdditiveExpression() 
		(
			(
				symbol= <RELATIONSYMBOL> 
				|
				symbol= <LT>
				|
				symbol= <GT>
				|
				symbol=","
			)
			AdditiveExpression()/*@bgen(jjtree) #NormalExpression( 2) */
                        {
                          ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 
			(/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{
					jjtn001.setName(symbol.image);
				}
			)/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/ 
			//immer 2 Knoten bekommen einem Elternknoten "Relation"
		)*
	)
}

/*
 * eine Addition besteht aus:
 * - min. zwei Ausdr\u00fccken mit Operatoren deren Bindungsst\u00e4rke nicht h\u00f6her als die der Multiplikation
 * - dem additionszeichen: + oder - oder +- zwischen jeweils zwei Ausdr\u00fccken
 * - der erste term kann ein vorzeichen haben
 */
void AdditiveExpression()       : {

	Token symbol;

}
{
	(
		PraefixExpression() 
		|
		MultiplicativeExpression() 
	)
	(
		symbol= <ADDITIONSYMBOL> MultiplicativeExpression()/*@bgen(jjtree) #NormalExpression( 2) */
                {
                  ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/ 
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001,  2);
                          jjtc001 = false;
                        }
/*@egen*/
			{
				jjtn001.setName(symbol.image);
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/ 
	)*
}

/*
 * Eine PraefixExpression hat zwei kinder
 * - das Praefix
 * - einem mult-Ausdruck 
 */
void PraefixExpression() : {/*@bgen(jjtree) PraefixExpression */
  ASTPraefixExpression jjtn000 = new ASTPraefixExpression(JJTPRAEFIXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PraefixExpression */
        try {
/*@egen*/
	Praefix() MultiplicativeExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/*
 * ein PraefixOperator wie:  "-" kann auch ein "+" sein. 
 */
void Praefix() : {/*@bgen(jjtree) Praefix */
        ASTPraefix jjtn000 = new ASTPraefix(JJTPRAEFIX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Praefix */
        try {
/*@egen*/
	symbol= <ADDITIONSYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{

		jjtn000.setName(symbol.image);

	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * eine Multiplikation besteht aus:
 * - min zwei Ausdr\u00fccken mit Operatoren deren Bindungsst\u00e4rke nicht h\u00f6her als Division
 * - dem multiplikationszeichen zwischen jeweils 2 Operanden
 */
void MultiplicativeExpression()       : {
	Token symbol;
}
{
	DivisiveExpression() 
	(
		symbol= <MULTIPLICATIONSYMBOL> DivisiveExpression()/*@bgen(jjtree) #NormalExpression( 2) */
                {
                  ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/ 
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001,  2);
                          jjtc001 = false;
                        }
/*@egen*/
			{
				jjtn001.setName(symbol.image);
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/ 
	)*
}

/*
 * eine Division wird extra behandelt 
 * um einen Ausdruck wie 3*4/5 wie 3*(4/5) darzustellen 
 * die 3 steht so vor dem bruch
 */
void DivisiveExpression()       : {}
{
	ExponentialExpression() 
	(
		<DIVIDE>/*@bgen(jjtree) #Div( 2) */
                         {
                           ASTDiv jjtn001 = new ASTDiv(JJTDIV);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
                         }
                         try {
/*@egen*/ ExponentialExpression()/*@bgen(jjtree)*/
                         } catch (Throwable jjte001) {
                           if (jjtc001) {
                             jjtree.clearNodeScope(jjtn001);
                             jjtc001 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte001 instanceof RuntimeException) {
                             throw (RuntimeException)jjte001;
                           }
                           if (jjte001 instanceof ParseException) {
                             throw (ParseException)jjte001;
                           }
                           throw (Error)jjte001;
                         } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001,  2);
                           }
                         }
/*@egen*/ 
	)*
}

/*
 * Ein exponentieller Ausdruck ist gekennzeichnet durch:
 * - min zwei Ausdr\u00fccken ohne Pr\u00e4fix- und Infixoperatoren
 * - ein Dach "^" zwischen jeweils zwei Ausdr\u00fccken
 */
void ExponentialExpression()       : {}
{
	PostfixExpression() 
	(
		"^"/*@bgen(jjtree) #Expo( 2) */
                    {
                      ASTExpo jjtn001 = new ASTExpo(JJTEXPO);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*/ PostfixExpression()/*@bgen(jjtree)*/
                    } catch (Throwable jjte001) {
                      if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte001 instanceof RuntimeException) {
                        throw (RuntimeException)jjte001;
                      }
                      if (jjte001 instanceof ParseException) {
                        throw (ParseException)jjte001;
                      }
                      throw (Error)jjte001;
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                      }
                    }
/*@egen*/ 
		
	)*
}

/*
*Eine Postfix Expression ist gekennzeichnet durch: 
*- einen Term,ohne Infix- und Praefixoperatoren
* -einem Postfixoperator
*/
void PostfixExpression()       : {}
{/*@bgen(jjtree) #PostfixExpression(> 1) */
        {
          ASTPostfixExpression jjtn001 = new ASTPostfixExpression(JJTPOSTFIXEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			LOOKAHEAD(SymbolExpression())
			SymbolExpression() 
			|
			FunctionExpression() 
		)
		(
			Postfix() 
		)?
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

/*
 * ein Postfix operator wie "!" (Fakult\u00e4t)
*/
void Postfix() : {/*@bgen(jjtree) Postfix */
        ASTPostfix jjtn000 = new ASTPostfix(JJTPOSTFIX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Postfix */
        try {
/*@egen*/
	symbol= <POSTFIX>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{

		jjtn000.setName(symbol.image);

	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Ein Ausdruck mit dem Nabla-symbol
 * Nabla kann vor , hinter einem Ausdruck und alleine stehen
 */
void SymbolExpression() : {/*@bgen(jjtree) SymbolExpression */
  ASTSymbolExpression jjtn000 = new ASTSymbolExpression(JJTSYMBOLEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SymbolExpression */
        try {
/*@egen*/
	(
		FunctionExpression() SpecialSymbol() 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * der Nabla-knoten
 */
void SpecialSymbol() : {/*@bgen(jjtree) SpecialSymbol */
        ASTSpecialSymbol jjtn000 = new ASTSpecialSymbol(JJTSPECIALSYMBOL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token symbol;
}
{/*@bgen(jjtree) SpecialSymbol */
        try {
/*@egen*/
	symbol=<NABLA> | symbol= <DOTS>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(symbol.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FunctionExpression()       : {}
{
	MethodPath() 
	|
	Function()
	|
	Number()
	|
	Brackets()
}

void Function()       :{}
{
	FunctionDetailChooser()
	|
	MathFunction() 
	|
	SpecialFunction() 
	|
	DoubleFunction() 
	|
	Root()
	|
	Limes()
	|
	VecmathDefinition()
}

/*
 * eine eigens definierte Funktion wie f(x), kann auch einen index haben f[1](x)
*/
void MethodPath()       : {}
{/*@bgen(jjtree) #MethodPath(> 1) */
        {
          ASTMethodPath jjtn001 = new ASTMethodPath(JJTMETHODPATH);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	//folgende Grammatik funktioniert leider nicht:
	//Eval*(Indeces|( (Indeces Eval+)+ Indeces?)?
	(
		Variable()
		(
			(
				EvalStep()
				{jjtn001.setFunction(true);}
			)
			|
			(
				Indeces()
				{jjtn001.setFunction(false);}
			)
		)*/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  jjtc001 = false;
                }
/*@egen*/
		{
			jjtn001.setModifierMap(modifierMap);
			jjtn001.setBroker(broker);
		}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
	
}

void FunctionDetailChooser():{/*@bgen(jjtree) FunctionDetailChooser */
        ASTFunctionDetailChooser jjtn000 = new ASTFunctionDetailChooser(JJTFUNCTIONDETAILCHOOSER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token type;
}
{/*@bgen(jjtree) FunctionDetailChooser */
        try {
/*@egen*/
	type= <FUNCTION_PREFIX>
	{
		jjtn000.setName(type.image);
		jjtn000.setBroker(broker);
		jjtn000.setModifierMap(modifierMap);
	}
	"("
	(
	MethodPath()
	)
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Funktionen, wie: sin, cos, tan,...
*/
void MathFunction() : {/*@bgen(jjtree) MathFunction */
        ASTMathFunction jjtn000 = new ASTMathFunction(JJTMATHFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token type;

}
{/*@bgen(jjtree) MathFunction */
        try {
/*@egen*/
	(
		(type= <MATHFUNCTION> ("(" AdditiveExpression() ")" )?)
		|
		(type= <LOG> (TwoDigitFunction() )?)
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(type.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * spezielle Funktionen sind sum(..), int(..), prod(..) usw.
*/
void SpecialFunction()       : {
	Token symbol;
}
{/*@bgen(jjtree) SpecialFunction */
        {
          ASTSpecialFunction jjtn001 = new ASTSpecialFunction(JJTSPECIALFUNCTION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			symbol= <SUM> Sum()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{
				jjtn001.setName(symbol.image);
			}
		)
		|
		(
			symbol= <PROD> Prod()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{
				jjtn001.setName(symbol.image);
			}
		)
		|
		(
			symbol= <INT> Int()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{
				jjtn001.setName(symbol.image);
			}
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	|
	Derive() 
	|
	PDerive() 
	|
	Transpose()
	|
	Inverse()
	|
	(
		symbol= <EXIST> Exist() 
	)
	|
	(
		symbol= <FORALL> ForAll() 
	)
}

void Sum()       : {}
{
	"(" FunctionExpression() "," AdditiveExpression() "," AdditiveExpression() "," AdditiveExpression() ")" 
}

void Prod()       : {}
{
	"(" FunctionExpression() "," AdditiveExpression() "," AdditiveExpression() "," AdditiveExpression() ")" 
}

void Derive() : {/*@bgen(jjtree) Derive */
  ASTDerive jjtn000 = new ASTDerive(JJTDERIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Derive */
        try {
/*@egen*/
	<DERIVE> "(" 
	(
		<VARS> EvalStep()","
		{
			jjtn000.setVars(true);
		}
	)?
	AdditiveExpression() 
	(
		(
			"," AdditiveExpression()")"
			{
				jjtn000.setDim(true);
			}
		)
		|/*@bgen(jjtree) Number */
                {
                  ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(
			")"/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{jjtn001.setName("1");}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/
	)
	(EvalStep(){jjtn000.setEval(true);})?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PDerive() : {/*@bgen(jjtree) PDerive */
  ASTPDerive jjtn000 = new ASTPDerive(JJTPDERIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PDerive */
        try {
/*@egen*/
	<PDERIVE> "("
	(
		<VARS> EvalStep()","
		{
			jjtn000.setVars(true);
		}
	)?
	AdditiveExpression() ("," FunctionExpression())+ ")" 
	(
		EvalStep()
		{
			jjtn000.setEval(true);
		}
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Int()       : {}
{
	"(" FunctionExpression() "," 
	AdditiveExpression() 
	(
		"," 
		AdditiveExpression() ","
		AdditiveExpression()
	)?
	")" 
}

void Transpose()      :{}
{/*@bgen(jjtree) Expo */
        {
          ASTExpo jjtn002 = new ASTExpo(JJTEXPO);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	(
		<TRANSPOSE> 
		"(" Variable() ")"/*@bgen(jjtree) Symbol */
                {
                  ASTSymbol jjtn001 = new ASTSymbol(JJTSYMBOL);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/ 
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/
			{jjtn001.setName("T");}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/
}

void Inverse()      :{}
{/*@bgen(jjtree) Expo */
        {
          ASTExpo jjtn002 = new ASTExpo(JJTEXPO);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	(
	<INVERSE> "(" Variable() ")"/*@bgen(jjtree) Number */
                                     {
                                       ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
                                     }
                                     try {
/*@egen*/ (/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn001, true);
                                        jjtc001 = false;
                                      }
/*@egen*/{jjtn001.setName("-1");})/*@bgen(jjtree)*/
                                     } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001, true);
                                       }
                                     }
/*@egen*/
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/
}

// 3-stellige funktion schreibweise und parameter??
void Exist()       : {}
{
	"(" FunctionExpression() "," FunctionExpression() "," FunctionExpression() ")" 
}

// 3-stellige funktion schreibweise und parameter??
void ForAll()       : {}
{
	"(" FunctionExpression() "," FunctionExpression() "," FunctionExpression() ")" 
}

// body f\u00fcr 2-stellige Funktionen
void TwoDigitFunction()       : {}
{
	"(" AdditiveExpression() "," AdditiveExpression() ")" 
}

/**
 * Ausdr\u00fccke die sowohl durch OperationsZeichen als auch durch Funktionen erzeugt werden k\u00f6nnen
 * expo(..,..) und fac(..)
 */
void DoubleFunction()       : {
	Token type;

}
{/*@bgen(jjtree) PostfixExpression */
        {
          ASTPostfixExpression jjtn003 = new ASTPostfixExpression(JJTPOSTFIXEXPRESSION);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	(
		<FAC> "("/*@bgen(jjtree) #Brackets( ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 16) */
                {
                  ASTBrackets jjtn001 = new ASTBrackets(JJTBRACKETS);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/ 
		(
			AdditiveExpression() 
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 16);
                  }
                }
/*@egen*/")"/*@bgen(jjtree) Postfix */
                {
                  ASTPostfix jjtn002 = new ASTPostfix(JJTPOSTFIX);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/ 
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn002, true);
                          jjtc002 = false;
                        }
/*@egen*/
			{
				jjtn002.setName("!");
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                  }
                }
/*@egen*/
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/
	|/*@bgen(jjtree) Expo */
        {
          ASTExpo jjtn006 = new ASTExpo(JJTEXPO);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*/
	(
		<POW> "("/*@bgen(jjtree) #Brackets( ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 18) */
                {
                  ASTBrackets jjtn004 = new ASTBrackets(JJTBRACKETS);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                }
                try {
/*@egen*/ 
		(
			AdditiveExpression() 
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte004) {
                  if (jjtc004) {
                    jjtree.clearNodeScope(jjtn004);
                    jjtc004 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte004 instanceof RuntimeException) {
                    throw (RuntimeException)jjte004;
                  }
                  if (jjte004 instanceof ParseException) {
                    throw (ParseException)jjte004;
                  }
                  throw (Error)jjte004;
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004,  ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 18);
                  }
                }
/*@egen*/
		","/*@bgen(jjtree) Brackets */
                    {
                      ASTBrackets jjtn005 = new ASTBrackets(JJTBRACKETS);
                      boolean jjtc005 = true;
                      jjtree.openNodeScope(jjtn005);
                    }
                    try {
/*@egen*/ (AdditiveExpression())/*@bgen(jjtree)*/
                    } catch (Throwable jjte005) {
                      if (jjtc005) {
                        jjtree.clearNodeScope(jjtn005);
                        jjtc005 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte005 instanceof RuntimeException) {
                        throw (RuntimeException)jjte005;
                      }
                      if (jjte005 instanceof ParseException) {
                        throw (ParseException)jjte005;
                      }
                      throw (Error)jjte005;
                    } finally {
                      if (jjtc005) {
                        jjtree.closeNodeScope(jjtn005, true);
                      }
                    }
/*@egen*/ ")"
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte006) {
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte006 instanceof RuntimeException) {
            throw (RuntimeException)jjte006;
          }
          if (jjte006 instanceof ParseException) {
            throw (ParseException)jjte006;
          }
          throw (Error)jjte006;
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
          }
        }
/*@egen*/
	|/*@bgen(jjtree) Expo */
        {
          ASTExpo jjtn009 = new ASTExpo(JJTEXPO);
          boolean jjtc009 = true;
          jjtree.openNodeScope(jjtn009);
        }
        try {
/*@egen*/
	(
		<EXPO> "("/*@bgen(jjtree) #Number(true) */
                {
                  ASTNumber jjtn007 = new ASTNumber(JJTNUMBER);
                  boolean jjtc007 = true;
                  jjtree.openNodeScope(jjtn007);
                }
                try {
/*@egen*/
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn007, true);
                          jjtc007 = false;
                        }
/*@egen*/
			{
				jjtn007.setName("e");
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc007) {
                    jjtree.closeNodeScope(jjtn007, true);
                  }
                }
/*@egen*//*@bgen(jjtree) Brackets */
                {
                  ASTBrackets jjtn008 = new ASTBrackets(JJTBRACKETS);
                  boolean jjtc008 = true;
                  jjtree.openNodeScope(jjtn008);
                }
                try {
/*@egen*/
		(
			AdditiveExpression()
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte008) {
                  if (jjtc008) {
                    jjtree.clearNodeScope(jjtn008);
                    jjtc008 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte008 instanceof RuntimeException) {
                    throw (RuntimeException)jjte008;
                  }
                  if (jjte008 instanceof ParseException) {
                    throw (ParseException)jjte008;
                  }
                  throw (Error)jjte008;
                } finally {
                  if (jjtc008) {
                    jjtree.closeNodeScope(jjtn008, true);
                  }
                }
/*@egen*/ 
		")"
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte009) {
          if (jjtc009) {
            jjtree.clearNodeScope(jjtn009);
            jjtc009 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte009 instanceof RuntimeException) {
            throw (RuntimeException)jjte009;
          }
          if (jjte009 instanceof ParseException) {
            throw (ParseException)jjte009;
          }
          throw (Error)jjte009;
        } finally {
          if (jjtc009) {
            jjtree.closeNodeScope(jjtn009, true);
          }
        }
/*@egen*/
}

void Root() : {/*@bgen(jjtree) Root */
        ASTRoot jjtn000 = new ASTRoot(JJTROOT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token symbol;
}
{/*@bgen(jjtree) Root */
        try {
/*@egen*/
	(
		(
			symbol=<SQRT>
			"(" AdditiveExpression() ")"/*@bgen(jjtree) Number */
                        {
                          ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001, true);
                                  jjtc001 = false;
                                }
/*@egen*/
				{jjtn001.setName("2");}
			)/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                          }
                        }
/*@egen*/
		)
		|
		symbol=<ROOT>
		"(" AdditiveExpression() "," AdditiveExpression() ")"
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(symbol.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Limes():{/*@bgen(jjtree) Limes */
        ASTLimes jjtn000 = new ASTLimes(JJTLIMES);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token symbol;
}
{/*@bgen(jjtree) Limes */
        try {
/*@egen*/
	symbol=<LIM>
		{
			jjtn000.setName(symbol.image);
		}
	"("
	<VARS>"("Ident()")"
	","
	AdditiveExpression()
	","
	AdditiveExpression()
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * spezieller Ausdruck zur Definition von Vektoren und Matrizen 
*/
void VecmathDefinition() : {/*@bgen(jjtree) VecmathDefinition */
        ASTVecmathDefinition jjtn000 = new ASTVecmathDefinition(JJTVECMATHDEFINITION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int test;
	int test2;
	Token type;

}
{/*@bgen(jjtree) VecmathDefinition */
        try {
/*@egen*/
	type= <VECMATH> 
	{
		jjtn000.setName(type.image);
	}
	"("
	
	(
		LOOKAHEAD(2)
		"{"test= Braces() "}"
		|
		(
			"{""{"
			test= Braces()
			"}"
			(
				",""{" test2= Braces() "}"
				{
					if (test != test2) 
					{
						throw new ParseException(
							"Ungleiche Spalten bei Matrix in Zeile: " + token.next.beginLine);
					}
				}
			)*
			"}"
		)
	)
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}


void EvalStep() : {/*@bgen(jjtree) EvalStep */
  ASTEvalStep jjtn000 = new ASTEvalStep(JJTEVALSTEP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EvalStep */
        try {
/*@egen*/

	"(" AdditiveExpression() 
	(
		"," AdditiveExpression() 
	)*
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * wird zur Definition von Vektoren und Matrizen verwendet "{...}"
 */
int Braces() : {/*@bgen(jjtree) Braces */
        ASTBraces jjtn000 = new ASTBraces(JJTBRACES);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int counter= 1;
}
{/*@bgen(jjtree) Braces */
        try {
/*@egen*/
	AdditiveExpression() 
	(
		"," AdditiveExpression() 
		{
			counter++;
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{
		return counter;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * ein Indeces- Knoten
 */
void Indeces(): {/*@bgen(jjtree) Indeces */
        ASTIndeces jjtn000 = new ASTIndeces(JJTINDECES);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Indeces */
                try {
/*@egen*/
		("[" AdditiveExpression() ( "," AdditiveExpression() )* "]"/*@bgen(jjtree)*/
                                                                            {
                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
                                                                            }
/*@egen*/ {jjtn000.setName("[");})
		|
		(PointExpression()/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/{jjtn000.setName(".");})
		|
		(
			"_" 
			{jjtn000.setName("_");}
			(
				Number()
				|/*@bgen(jjtree) #Ident(true) */
                                {
                                  ASTIdent jjtn001 = new ASTIdent(JJTIDENT);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*/
				(
					(
						t=<STRUCTURE>
					)/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001, true);
                                          jjtc001 = false;
                                        }
/*@egen*/
					{jjtn001.setName(t.image);}
				)/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                  }
                                }
/*@egen*/
				|
				Ident()
				|
				FunctionHeader()
			)	
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	
}

/*
 * ein geklammerter Ausdruck. sowohl "(...)" als auch "|...|"
 */
void Brackets() : {/*@bgen(jjtree) Brackets */
        ASTBrackets jjtn000 = new ASTBrackets(JJTBRACKETS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Brackets */
        try {
/*@egen*/
	(
		(
			symbol= "(" Expression() ")" 
		)
		|
		(
			symbol= "|" AdditiveExpression() "|" 
		)
		|
		(
			symbol= "[" AdditiveExpression() "]" 
		)
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(symbol.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * eine Variable kann sowohl ein Identifier als auch ein symbol wie gr. Buchstabe sein
 * au\u00dferdem kann es ein Nabla sein oder ein Nabla und eine variable.
 */
void Variable()       : {}
{/*@bgen(jjtree) #SymbolExpression(> 1) */
        {
          ASTSymbolExpression jjtn001 = new ASTSymbolExpression(JJTSYMBOLEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			SpecialSymbol() 
			(
				//(
				//	LOOKAHEAD(PointExpression())
				//	PointExpression() 
				//	|
				//	Ident()
				//)
				Ident()
				|
				UndefinedVector() 
				|
				VecmathSymbol() 
				|
				UndefinedMatrix()
			)?
		)
		|
		(
			//(
				//	LOOKAHEAD(PointExpression())
				//	PointExpression() 
				//	|
				//	Ident()
				//)
			Ident()
			|
			UndefinedVector() 
			|
			VecmathSymbol() 
			|
			UndefinedMatrix()
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

void VecmathSymbol() : {/*@bgen(jjtree) VecmathSymbol */
        ASTVecmathSymbol jjtn000 = new ASTVecmathSymbol(JJTVECMATHSYMBOL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) VecmathSymbol */
        try {
/*@egen*/
	(
		t=<VECMATHSYMBOL>
		{
			jjtn000.setName(t.image);
		}
	)
	Ident()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void UndefinedVector() : {/*@bgen(jjtree) UndefinedVector */
        ASTUndefinedVector jjtn000 = new ASTUndefinedVector(JJTUNDEFINEDVECTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	Token t2;
}
{/*@bgen(jjtree) UndefinedVector */
        try {
/*@egen*/
	t= <UNDEFVECTOR> 
	{
		jjtn000.setName(t.image);
	}
	(/*@bgen(jjtree) Number */
                {
                  ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(
			(
				t2= <INTEGER_LITERAL> 
				|
				t2= <IDENTIFIER> 
			)/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/
			{
				jjtn001.setName(t2.image);
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/
	)
	")" <GT>
	Ident()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}


  //erstellt eine matrix mit werten vom Typ m[1][1],m[1][2],...,m[1][n],m[2][1],...m[n][k];
void UndefinedMatrix() : {/*@bgen(jjtree) UndefinedMatrix */
        ASTUndefinedMatrix jjtn000 = new ASTUndefinedMatrix(JJTUNDEFINEDMATRIX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) UndefinedMatrix */
        try {
/*@egen*/
	<UNDEFMATRIX>/*@bgen(jjtree) Number */
        {
          ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			t= <INTEGER_LITERAL> 
			|
			t= <IDENTIFIER> 
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/
		{
			jjtn001.setName(t.image);
		}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/","/*@bgen(jjtree) #Number(true) */
        {
          ASTNumber jjtn002 = new ASTNumber(JJTNUMBER);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ 
	(
		(
			t= <INTEGER_LITERAL> 
			|
			t= <IDENTIFIER> 
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002, true);
                  jjtc002 = false;
                }
/*@egen*/
		{
			jjtn002.setName(t.image);
		}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/")"( <GT>) Ident()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void PointExpression()      :{}
{
	"."
	Ident()
}

void FunctionHeader()      :{
Token t;
}
{/*@bgen(jjtree) #Ident(true) */
        {
          ASTIdent jjtn001 = new ASTIdent(JJTIDENT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			t=<ROOT>
			|
			t=<SQRT>
			|
			t=<LIM>
			|
			t=<SUM>
			|
			t=<INT>
			|
			t=<PROD>
			|
			t=<DERIVE>
			|
			t=<PDERIVE>
			|
			t=<EXIST>
			|
			t=<FORALL>
			|
			t=<VARS>
			|
			t=<MATHFUNCTION>
			|
			t=<LOG>
			|
			t=<FAC>
			|
			t=<EXPO>
			|
			t=<POW>
			|
			t=<INVERSE>
			|
			t=<TRANSPOSE>
			|
			t=<VECMATH>
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/
		{jjtn001.setName(t.image);}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
}

void Ident()      : {

	Token symbol;
	String s;

}
{/*@bgen(jjtree) #SpecialIdent(> 1) */
        {
          ASTSpecialIdent jjtn001 = new ASTSpecialIdent(JJTSPECIALIDENT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
	
		PureIdent()
		(
			(symbol="~") (Number()|PureIdent())
			{
				jjtn001.setName(symbol.image);
				jjtn001.setModifierMap(modifierMap);
				jjtn001.setBroker(broker);
				
			}
		)?
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
	
	
}

void PureIdent()      : {

	Token t;
	String s;

}
{/*@bgen(jjtree) Ident */
        {
          ASTIdent jjtn001 = new ASTIdent(JJTIDENT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			t= <IDENTIFIER>
			|
			t=<SYMBOL>
			|
			t=<VOIDELEMENT>
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/
		{
			jjtn001.setName(t.image);
			Map m = (Map)modifierMap.get(t.image);
			if(m!=null){
				jjtn001.setModifier(m);
				jjtn001.setBroker(broker);
			}
		}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	
}

void Number() : {/*@bgen(jjtree) Number */
        ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Number */
        try {
/*@egen*/
	(
		symbol= <INFIN> 
		|
		symbol= <EULER> 
		|
		symbol= <PI> 
		|
		symbol= <FLOAT_LITERAL> 
		|
		symbol= <INTEGER_LITERAL> 
		
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{

		jjtn000.setName(symbol.image);

	}
	|
	(
		symbol= <ENUMBER>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			jjtn000.setName(symbol.image.replace('e','E'));
		}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
