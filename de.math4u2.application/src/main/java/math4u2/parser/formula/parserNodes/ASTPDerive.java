/* Generated By:JJTree: Do not edit this line. ASTPDerive.java */

package math4u2.parser.formula.parserNodes;

import math4u2.view.formula.*;
import math4u2.view.layout.IndexLayout;
import math4u2.parser.formula.*;

/**
 * Klasse für partielle Ableitungen
 * 
 * @author Christoph Beckmann
 */

public class ASTPDerive extends SimpleNode {
    private boolean eval = false;

    private boolean isVars = false;

    public ASTPDerive(int id) {
        super(id);
    }

    public ASTPDerive(fsParser p, int id) {
        super(p, id);
    }

    public void setName(String symbol) {
        super.symbol = symbol;
    }

    public void setEval(boolean eval) {
        this.eval = eval;
    }

    public void setVars(boolean isVars) {
        this.isVars = isVars;
    }

    /*
     * (non-Javadoc)
     * 
     * @see math4u2.view.parser.SimpleNode#bakeComponents(math4u2.view.formula.AtomicBox)
     */
    public void bakeComponents(AtomicBox ab) {
        FormulaRenderContext frc = ab.getRenderContext();
        // Index der ersten Variable nach der abgeleitet wird
        int firstDeriveVarNum = 1;
        // Anzahl der Variablen nach denen Abgeleitet wird
        int deriveVarsCount = jjtGetNumChildren() - 1;
        int termIndex = 0;
        if (isVars) {
            // erstes Kind (vars-Term) ignorieren
            firstDeriveVarNum++;
            deriveVarsCount--;
            termIndex++;
        }
        if (eval) {
            deriveVarsCount--;
        }

        InnerBox ib = new InnerBox(frc);
        ContainerBox up = new ContainerBox(frc);
        ContainerBox down = new ContainerBox(frc);

        // Zähler
        AtomicBox par;
        if (deriveVarsCount > 1) {
            par = new IndexedBox(frc);
            par.add(new OrdBox(frc, "$part"), IndexLayout.CENTER);
            par.add(new OrdBox(frc, String.valueOf(deriveVarsCount)),
                    IndexLayout.RIGHT_TOP);
        } else {
            par = new OrdBox(frc, "$part");
        }
        up.add(par);
        ib.add(up);

        // Nenner
        for (int i = 0; i < deriveVarsCount; i++) {
            down.add(new OrdBox(frc, "$part"));
            jjtGetChild(firstDeriveVarNum + i).bakeComponents(down);
        }

        ib.add(down);

        // Folgt ein eval?
        if (eval) {
            // Baue Klammer um Ableitungsterm
            BracketedBox bb = new BracketedBox(frc);
            bb.add(ib);
            jjtGetChild(termIndex).bakeComponents(bb);
            ab.add(bb);

            // Baue EvalTerm
            jjtGetChild(jjtGetNumChildren()-1).bakeComponents(ab);
        } else {
            ab.add(ib);
            jjtGetChild(termIndex).bakeComponents(ab);
        }

    }

    /*
     * (non-Javadoc)
     * 
     * @see math4u2.parser.formula.parserNodes.SimpleNode#toString()
     */
    public String toString() {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < children.length; i++) {
            sb.append(jjtGetChild(i).toString());
            if (i < children.length - 1)
                sb.append(",");
        }
        return "pderive(" + sb.toString() + ")";
    }

}