/* Generated By:JJTree: Do not edit this line. ASTUndefinedMatrix.java */

package math4u2.parser.formula.parserNodes;

import math4u2.view.formula.*;
import math4u2.view.layout.IndexLayout;
import math4u2.parser.formula.*;

/**
 * Klasse für Matrizen mit werten vom Typ
 * m[1][1],m[1][2],...,m[1][i],m[2][1],...m[i][k];
 * 
 * @author Chrisotph Beckmann
 */
public class ASTUndefinedMatrix extends SimpleNode {

    private int maxNrofRows = 3;

    private int maxNrofCols = 3;

    public ASTUndefinedMatrix(int id) {
        super(id);
    }

    public ASTUndefinedMatrix(fsParser p, int id) {
        super(p, id);
    }

    /*
     * (non-Javadoc)
     * 
     * @see math4u2.view.parser.SimpleNode#bakeComponents(math4u2.view.formula.AtomicBox)
     */
    public void bakeComponents(AtomicBox ab) {
        String var = ((SimpleNode) jjtGetChild(2)).getSymbol();
        int gbRows;
        int gbCols;
        String nrofRows = ((SimpleNode) jjtGetChild(0)).getSymbol();
        String nrofCols = ((SimpleNode) jjtGetChild(1)).getSymbol();
        boolean rowsTooBig = false;
        boolean colsTooBig = false;

        try {
            gbRows = Integer.parseInt(nrofRows);
        } catch (NumberFormatException nfe) {
            gbRows = maxNrofRows;
            rowsTooBig = true;
        }
        try {
            gbCols = Integer.parseInt(nrofRows);
        } catch (NumberFormatException nfe) {
            gbCols = maxNrofCols;
            colsTooBig = true;
        }

        if (gbRows > maxNrofRows) {
            gbRows = maxNrofRows;
            rowsTooBig = true;
        }
        if (gbCols > maxNrofCols) {
            gbCols = maxNrofCols;
            colsTooBig = true;
        }

        FormulaRenderContext frc = ab.getRenderContext();
        GridBox gb = new GridBox(frc, gbRows, gbCols);
        AtomicBox[][] matrix = new AtomicBox[gbCols][gbRows];
        IndexedBox ib;

        //	Füllen der matrix bis auf letzte Spalte und Zeile
        for (int i = 0; i < matrix.length - 1; i++) {
            for (int j = 0; j < matrix[i].length - 1; j++) {
                ib = new IndexedBox(frc);
                ib.add(new OrdBox(frc, var), IndexLayout.CENTER);
                ContainerBox index = new ContainerBox(frc);
                index.add(new OrdBox(frc, Integer.toString(i + 1)));
                index.add(new OrdBox(frc, ","));
                index.add(new OrdBox(frc, Integer.toString(j + 1)));
                ib.add(index, IndexLayout.RIGHT_BOTTOM);
                matrix[i][j] = ib;
            }
        }

        //	Füllen der letzten Zeile
        for (int i = 0; i < matrix[0].length; i++) {
            ib = new IndexedBox(frc);
            ib.add(new OrdBox(frc, var), IndexLayout.CENTER);
            ContainerBox index = new ContainerBox(frc);
            index.add(new OrdBox(frc, nrofCols));
            index.add(new OrdBox(frc, ","));
            index.add(new OrdBox(frc, Integer.toString(i + 1)));
            ib.add(index, IndexLayout.RIGHT_BOTTOM);
            matrix[matrix.length - 1][i] = ib;
        }

        //	Füllen der letzten Zeile
        for (int i = 0; i < matrix.length - 1; i++) {
            ib = new IndexedBox(frc);
            ib.add(new OrdBox(frc, var), IndexLayout.CENTER);
            ContainerBox index = new ContainerBox(frc);
            index.add(new OrdBox(frc, Integer.toString(i + 1)));
            index.add(new OrdBox(frc, ","));
            index.add(new OrdBox(frc, nrofRows));
            ib.add(index, IndexLayout.RIGHT_BOTTOM);
            matrix[i][matrix[0].length - 1] = ib;
        }

        //	Füllen der letzten Zelle
        ib = new IndexedBox(frc);
        ib.add(new OrdBox(frc, var), IndexLayout.CENTER);
        ContainerBox index = new ContainerBox(frc);
        index.add(new OrdBox(frc, nrofCols));
        index.add(new OrdBox(frc, ","));
        index.add(new OrdBox(frc, nrofRows));
        ib.add(index, IndexLayout.RIGHT_BOTTOM);
        matrix[gbCols - 1][gbRows - 1] = ib;

        //	Einbauen von Horizontalpunktereihe falls Spaltenanzahl zu groß
        if (rowsTooBig) {
            for (int i = 0; i < matrix.length; i++) {
                matrix[i][1] = new OrdBox(frc, "$hdots");
            }
        }

        //	Einbauen von Vertikalpunktereihe falls Zeilenanzahl zu groß
        if (colsTooBig) {
            for (int i = 0; i < matrix[1].length; i++) {
                matrix[1][i] = new OrdBox(frc, "$vdots");
            }
            //		Einbauen der Diagonalpunktereihe in der Mitte der matrix
            //		falls Zeilen- und Spaltenanzahl zu groß
            if (rowsTooBig) {
                matrix[1][1] = new OrdBox(frc, "$ddots");
            }
        }

        //	Füllen der Gridbox mit den Werten aus der matrix
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                gb.add(matrix[i][j]);
            }
        }
        MatrixBox bb = new MatrixBox(frc);
        bb.add(gb);
        ab.add(bb);
    }

    /*
     * (non-Javadoc)
     * 
     * @see math4u2.parser.formula.parserNodes.SimpleNode#toString()
     */
    public String toString() {
        return "<matrix(" + jjtGetChild(0).toString() + ","
                + jjtGetChild(1).toString() + ")>" + jjtGetChild(2);
    }

}