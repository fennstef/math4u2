/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. math4u2\parser\formulaold\fsParser.jj */
/*@egen*//*options {
	MULTI=true;
    NODE_PACKAGE= "math4u2.parser.formula.parserNodes";
    STATIC = false;
	OUTPUT_DIRECTORY = "math4u2\\parser\\formula";
}*/


PARSER_BEGIN(fsParser)

package math4u2.parser.formulaold;

import java.util.*;
import math4u2.parser.formulaold.parserNodes.*;
import math4u2.controller.*;

public class fsParser/*@bgen(jjtree)*/implements fsParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTfsParserState jjtree = new JJTfsParserState();

/*@egen*/
	private Map modifierMap= new HashMap();
	private Broker broker;
	public static void main(String args[]) {}

	public void setModifierMap(Map modifierMap) {
        this.modifierMap= modifierMap;
    }
    
    public Map getModifierMap() {
        return modifierMap;
    }
    
    public Node parse(Broker broker) throws ParseException{
        this.broker=broker;
        return Start();
    }
}

PARSER_END(fsParser)

SKIP :
{
	" " 
	|
	"\t" 
	|
	"\n" 
	|
	"\r" 
	|
	< 
		"//"
		( ~[ "\n", "\r" ] )*
		( "\n" | "\r" | "\r\n" )
	>
	|
	< 
		"/*"
		( ~[ "*" ] )*
		"*"
		(
			~[ "/" ]
			( ~[ "*" ] )*
			"*"
		)*
		"/"
	>
}

TOKEN :
/*INFIX_OPERATORS*/

{
	<RELATIONSYMBOL : 
		( [ "=", "<", ">" ] | "!=" | "<=" | ">=" )
		|
		<ARROW>
		|
		<REL_STRING_INFIX>
	>
	|
	<#ARROW : 
		"&"
		( "larr" | "rarr" | "uarr" | "darr" | "harr" | "lArr" | "rArr" | "uArr" | "dArr" | "hArr" )
		";"
	>
	|
	<#REL_STRING_INFIX : 
		"&"
		(
			"ne"
			|
			"equiv"
			|
			"lt"
			|
			"gt"
			|
			"le"
			|
			"ge"
			|
			"sub"
			|
			"sup"
			|
			"nsub"
			|
			"supe"
			|
			"perp"
			|
			"isin"
			|
			"notin"
			|
			"ni"
			|
			"prop"
			|
			"sim"
			|
			"cong"
			|
			"asymp"
			|
			"and"
			|
			"or"
			|
			"cap"
			|
			"cup"
		)
		";"
	>
	|
	<ADDITIONSYMBOL : 
		[ "+", "-" ]
		|
		"+-"
		|
		<ADD_STRING>
	>
	|
	<#ADD_STRING : 
		"&"
		( "plusmn" | "oplus" )
		";"
	>
	|
	<MULTIPLICATIONSYMBOL : 
		<MULT >
		|
		<MULT_STRING>
	>
	|
	<#MULT : 
		"*"
	>
	|
	<#MULT_STRING : 
		"&otimes;"
		|
		"&sdot;"
		|
		"&mdot;"
	>
	|
	<DIVIDE : 
		"/"
	>
}

TOKEN :
/* POST_PREFIX_OPERATORS */

{
	<POSTFIX : 
		"%"
		|
		"!"
	>
	|
	<STRING_PREFIX : 
		"&"
		( "not" | "ang" )
		";"
	>
}

TOKEN :
/* FUNCTIONS */

{
	<ROOT : 
		"root"
	>
	|
	<SQRT : 
		"sqrt"
	>
	|
	<SUM : 
		"sum"
	>
	|
	<INT : 
		"int"
	>
	|
	<PROD : 
		"prod"
	>
	|
	<DERIVE : 
		"derive"
	>
	|
	<PDERIVE : 
		"pderive"
	>
	|
	<EXIST : 
		"exist"
	>
	|
	<FORALL : 
		"forall"
	>
	|
	<MATHFUNCTION : 
		"sin"
		|
		"cos"
		|
		"tan"
		|
		"arcsin"
		|
		"arccos"
		|
		"arctan"
		|
		"ln"
		|
		"lg"
	>
	|
	<LOG : 
		"log"
	>
	|
	<FAC : 
		"fac"
	>
	|
	<EXPO : 
		"expo"
	>
	|
	<VECMATH : 
		<MATRIX>
		|
		<VECTOR>
		|
		<DUALVEKTOR>
	>
	|
	<#MATRIX : 
		"matrix"
	>
	|
	<#VECTOR : 
		"vektor"
	>
	|
	<#DUALVEKTOR : 
		"dualvektor"
	>
	|
	<UNDEFVECTOR : 
		"<vektor("
		|
		"<dualvektor("
	>
	|
	<UNDEFMATRIX : 
		"<matrix("
	>
}

TOKEN :
/* LITERALS */

{
	<FLOAT_LITERAL : 
		<INTEGER_LITERAL>
		"."
		<INTEGER_LITERAL>
	>
	|
	<INTEGER_LITERAL : 
		<DIGIT>
		( <DIGIT> )*
	>
	|
	<#DIGIT : 
		[ "0"-"9" ]
		( [ "0"-"9" ] )*
	>
	|
	<INFIN : 
		"&infin;"
	>
	|
	<EULER : 
		"e"
	>
	|
	<PI : 
		"&pi;"
	>
}

TOKEN :
/* SYMBOLS */

{
	<SYMBOL : 
		<GR_LETTER_UC>
	>
	|
	<#GR_LETTER_LC : 
		"&"
		(
			"fnof"
			|
			"alpha"
			|
			"beta"
			|
			"gamma"
			|
			"delta"
			|
			"epsilon"
			|
			"zeta"
			|
			"eta"
			|
			"theta"
			|
			"iota"
			|
			"kappa"
			|
			"lambda"
			|
			"mu"
			|
			"nu"
			|
			"xi"
			|
			"sigma"
			|
			"tau"
			|
			"upsilon"
			|
			"phi"
			|
			"chi"
			|
			"psi"
			|
			"omega"
		)
		";"
	>
	|
	<#GR_LETTER_UC : 
		"&"
		(
			"Alpha"
			|
			"Beta"
			|
			"Gamma"
			|
			"Delta"
			|
			"Theta"
			|
			"Lambda"
			|
			"Xi"
			|
			"Sigma"
			|
			"Upsilon"
			|
			"Omicron"
			|
			"Phi"
			|
			"Psi"
			|
			"Omega"
		)
		";"
	>
	|
	<NABLA : 
		"&nabla;"
	>
}

TOKEN :
/* IDENTIFIERS */

{
	< IDENTIFIER : 
		<LETTER>
		( <LETTER> | <DIGIT> )*
	>
	|
	< #LETTER : 
		[ "_", "a"-"z", "A"-"Z" ]
	>
}

ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{

		return jjtn000;

	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Ein Ausdruck kann sein
 * - Definition wie f(x):=
 * - Relation wie x+3 = 2*y - 4
 */
void Expression()       : {}
{
	LOOKAHEAD(Definition())
	Definition() 
	|
	RelationExpression() 
}

/*
 * eine Definition ist gekennzeichnet durch ein ":="
 */
void Definition()       : {}
{/*@bgen(jjtree) #NormalExpression(> 1) */
        {
          ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		FunctionExpression() ":=" RelationExpression()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  jjtc001 = false;
                }
/*@egen*/ 
		{
			jjtn001.setName(":=");
		}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

/*
 * eine Relation besteht aus:
 * - min. zwei Ausdr\u00fccken mit Operatoren deren Bindungsst\u00e4rke nicht h\u00f6her als die der Addition
 * - zwischen zwei Ausdr\u00fccken steht ein Relationszeichen: <, >, =, ...
 */
void RelationExpression()       : {

	Token symbol;

}
{
	(
		AdditiveExpression() 
		(
			symbol= <RELATIONSYMBOL> AdditiveExpression()/*@bgen(jjtree) #NormalExpression( 2) */
                        {
                          ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 
			(/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                  jjtc001 = false;
                                }
/*@egen*/
				{
					jjtn001.setName(symbol.image);
				}
			)/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
                        }
/*@egen*/ 
			//immer 2 Knoten bekommen einem Elternknoten "Relation"
		)*
	)
}

/*
 * eine Addition besteht aus:
 * - min. zwei Ausdr\u00fccken mit Operatoren deren Bindungsst\u00e4rke nicht h\u00f6her als die der Multiplikation
 * - dem additionszeichen: + oder - oder +- zwischen jeweils zwei Ausdr\u00fccken
 * - der erste term kann ein vorzeichen haben
 */
void AdditiveExpression()       : {

	Token symbol;

}
{
	(
		PraefixExpression() 
		|
		MultiplicativeExpression() 
	)
	(
		symbol= <ADDITIONSYMBOL> MultiplicativeExpression()/*@bgen(jjtree) #NormalExpression( 2) */
                {
                  ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/ 
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001,  2);
                          jjtc001 = false;
                        }
/*@egen*/
			{
				jjtn001.setName(symbol.image);
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/ 
	)*
}

/*
 * Eine PraefixExpression hat zwei kinder
 * - das Praefix
 * - einem mult-Ausdruck 
 */
void PraefixExpression() : {/*@bgen(jjtree) PraefixExpression */
  ASTPraefixExpression jjtn000 = new ASTPraefixExpression(JJTPRAEFIXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PraefixExpression */
        try {
/*@egen*/
	Praefix() MultiplicativeExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/*
 * ein PraefixOperator wie:  "-" kann auch ein "+" sein. 
 */
void Praefix() : {/*@bgen(jjtree) Praefix */
        ASTPraefix jjtn000 = new ASTPraefix(JJTPRAEFIX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Praefix */
        try {
/*@egen*/
	symbol= <ADDITIONSYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{

		jjtn000.setName(symbol.image);

	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * eine Multiplikation besteht aus:
 * - min zwei Ausdr\u00fccken mit Operatoren deren Bindungsst\u00e4rke nicht h\u00f6her als Division
 * - dem multiplikationszeichen zwischen jeweils 2 Operanden
 */
void MultiplicativeExpression()       : {
	Token symbol;
}
{
	DivisiveExpression() 
	(
		symbol= <MULTIPLICATIONSYMBOL> DivisiveExpression()/*@bgen(jjtree) #NormalExpression( 2) */
                {
                  ASTNormalExpression jjtn001 = new ASTNormalExpression(JJTNORMALEXPRESSION);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/ 
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001,  2);
                          jjtc001 = false;
                        }
/*@egen*/
			{
				jjtn001.setName(symbol.image);
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/ 
	)*
}

/*
 * eine Division wird extra behandelt 
 * um einen Ausdruck wie 3*4/5 wie 3*(4/5) darzustellen 
 * die 3 steht so vor dem bruch
 */
void DivisiveExpression()       : {}
{
	ExponentialExpression() 
	(
		<DIVIDE>/*@bgen(jjtree) #Div( 2) */
                         {
                           ASTDiv jjtn001 = new ASTDiv(JJTDIV);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
                         }
                         try {
/*@egen*/ ExponentialExpression()/*@bgen(jjtree)*/
                         } catch (Throwable jjte001) {
                           if (jjtc001) {
                             jjtree.clearNodeScope(jjtn001);
                             jjtc001 = false;
                           } else {
                             jjtree.popNode();
                           }
                           if (jjte001 instanceof RuntimeException) {
                             throw (RuntimeException)jjte001;
                           }
                           if (jjte001 instanceof ParseException) {
                             throw (ParseException)jjte001;
                           }
                           throw (Error)jjte001;
                         } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001,  2);
                           }
                         }
/*@egen*/ 
	)*
}

/*
 * Ein exponentieller Ausdruck ist gekennzeichnet durch:
 * - min zwei Ausdr\u00fccken ohne Pr\u00e4fix- und Infixoperatoren
 * - ein Dach "^" zwischen jeweils zwei Ausdr\u00fccken
 */
void ExponentialExpression()       : {}
{
	PostfixExpression() 
	(
		"^"/*@bgen(jjtree) #Expo( 2) */
                    {
                      ASTExpo jjtn001 = new ASTExpo(JJTEXPO);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*/ PostfixExpression()/*@bgen(jjtree)*/
                    } catch (Throwable jjte001) {
                      if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte001 instanceof RuntimeException) {
                        throw (RuntimeException)jjte001;
                      }
                      if (jjte001 instanceof ParseException) {
                        throw (ParseException)jjte001;
                      }
                      throw (Error)jjte001;
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                      }
                    }
/*@egen*/ 
		
	)*
}

/*
*Eine Postfix Expression ist gekennzeichnet durch: 
*- einen Term,ohne Infix- und Praefixoperatoren
* -einem Postfixoperator
*/
void PostfixExpression()       : {}
{/*@bgen(jjtree) #PostfixExpression(> 1) */
        {
          ASTPostfixExpression jjtn001 = new ASTPostfixExpression(JJTPOSTFIXEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			LOOKAHEAD(NablaExpression())
			NablaExpression() 
			|
			FunctionExpression() 
		)
		(
			Postfix() 
		)?
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

/*
 * ein Postfix operator wie "!" (Fakult\u00e4t)
*/
void Postfix() : {/*@bgen(jjtree) Postfix */
        ASTPostfix jjtn000 = new ASTPostfix(JJTPOSTFIX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Postfix */
        try {
/*@egen*/
	symbol= <POSTFIX>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{

		jjtn000.setName(symbol.image);

	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Ein Ausdruck mit dem Nabla-symbol
 * Nabla kann vor , hinter einem Ausdruck und alleine stehen
 */
void NablaExpression() : {/*@bgen(jjtree) NablaExpression */
  ASTNablaExpression jjtn000 = new ASTNablaExpression(JJTNABLAEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NablaExpression */
        try {
/*@egen*/
	(
		FunctionExpression() Nabla() 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * der Nabla-knoten
 */
void Nabla() : {/*@bgen(jjtree) Nabla */
  ASTNabla jjtn000 = new ASTNabla(JJTNABLA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Nabla */
        try {
/*@egen*/
	<NABLA>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void FunctionExpression()       : {}
{
	MethodPath() 
	|
	MathFunction() 
	|
	SpecialFunction() 
	|
	DoubleFunction() 
	|
	Root()
	|
	VecmathDefinition()
	|
	Number()
	|
	Brackets()
}

/*
 * eine eigens definierte Funktion wie f(x), kann auch einen index haben f[1](x)
*/
void MethodPath()       : {}
{
		
		(
			LOOKAHEAD(IndexedExpression())/*@bgen(jjtree) #NormalFunction(> 1) */
                        {
                          ASTNormalFunction jjtn001 = new ASTNormalFunction(JJTNORMALFUNCTION);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
				IndexedExpression()
				{
					//System.out.println("INDEXEDEXPRESSION");
				}
				(EvalStep())*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                          }
                        }
/*@egen*/
			|/*@bgen(jjtree) #IndexedExpression(> 1) */
                        {
                          ASTIndexedExpression jjtn003 = new ASTIndexedExpression(JJTINDEXEDEXPRESSION);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/
			(/*@bgen(jjtree) #NormalFunction(> 1) */
                                {
                                  ASTNormalFunction jjtn002 = new ASTNormalFunction(JJTNORMALFUNCTION);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/
				(
					Variable()
					(EvalStep())*
				)/*@bgen(jjtree)*/
                                } catch (Throwable jjte002) {
                                  if (jjtc002) {
                                    jjtree.clearNodeScope(jjtn002);
                                    jjtc002 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte002 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte002;
                                  }
                                  if (jjte002 instanceof ParseException) {
                                    throw (ParseException)jjte002;
                                  }
                                  throw (Error)jjte002;
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
                                  }
                                }
/*@egen*/
				(Indeces())?
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003, jjtree.nodeArity() > 1);
                          }
                        }
/*@egen*/
		)
}

void KeyWordStep()      :{}
{/*@bgen(jjtree) IndexedExpression */
        {
          ASTIndexedExpression jjtn001 = new ASTIndexedExpression(JJTINDEXEDEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		"."
		Ident()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
}

/*
 * Funktionen, wie: sin, cos, tan,...
*/
void MathFunction() : {/*@bgen(jjtree) MathFunction */
        ASTMathFunction jjtn000 = new ASTMathFunction(JJTMATHFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token type;

}
{/*@bgen(jjtree) MathFunction */
        try {
/*@egen*/
	(
		type= <MATHFUNCTION> "(" AdditiveExpression() ")" 
		|
		type= <LOG> TwoDigitFunction() 
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(type.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * spezielle Funktionen sind sum(..), int(..), prod(..) usw.
*/
void SpecialFunction()       : {
	Token symbol;
}
{/*@bgen(jjtree) SpecialFunction */
        {
          ASTSpecialFunction jjtn001 = new ASTSpecialFunction(JJTSPECIALFUNCTION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			symbol= <SUM> Sum()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{
				jjtn001.setName(symbol.image);
			}
		)
		|
		(
			symbol= <PROD> Prod()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{
				jjtn001.setName(symbol.image);
			}
		)
		|
		(
			symbol= <INT> Int()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ 
			{
				jjtn001.setName(symbol.image);
			}
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	|
	Derive() 
	|/*@bgen(jjtree) PDerive */
        {
          ASTPDerive jjtn002 = new ASTPDerive(JJTPDERIVE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	(
		symbol= <PDERIVE> PDerive()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002, true);
                  jjtc002 = false;
                }
/*@egen*/ 
		{
			jjtn002.setName(symbol.image);
		}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/
	|
	(
		symbol= <EXIST> Exist() 
	)
	|
	(
		symbol= <FORALL> ForAll() 
	)
}

void Sum()       : {}
{
	"(" FunctionExpression() "," AdditiveExpression() "," AdditiveExpression() "," AdditiveExpression() ")" 
}

void Prod()       : {}
{
	"(" FunctionExpression() "," AdditiveExpression() "," AdditiveExpression() "," AdditiveExpression() ")" 
}

void Derive() : {/*@bgen(jjtree) Derive */
        ASTDerive jjtn000 = new ASTDerive(JJTDERIVE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) Derive */
        try {
/*@egen*/
	<DERIVE> "(" AdditiveExpression() 
	{
		jjtn000.setName("1");
	}
	(
		"," t= <INTEGER_LITERAL> 
		{
			jjtn000.setName(t.image);
		}
	)?
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void PDerive()       : {}
{
	"(" AdditiveExpression() "," FunctionExpression() "," FunctionExpression() ")" 
}

void Int()       : {}
{
	"(" FunctionExpression() "," FunctionExpression() "," FunctionExpression() "," AdditiveExpression() ")" 
}

// 3-stellige funktion schreibweise und parameter??
void Exist()       : {}
{
	"(" FunctionExpression() "," FunctionExpression() "," FunctionExpression() ")" 
}

// 3-stellige funktion schreibweise und parameter??
void ForAll()       : {}
{
	"(" FunctionExpression() "," FunctionExpression() "," FunctionExpression() ")" 
}

// body f\u00fcr 2-stellige Funktionen
void TwoDigitFunction()       : {}
{
	"(" AdditiveExpression() "," AdditiveExpression() ")" 
}

/**
 * Ausdr\u00fccke die sowohl durch OperationsZeichen als auch durch Funktionen erzeugt werden k\u00f6nnen
 * expo(..,..) und fac(..)
 */
void DoubleFunction()       : {
	Token type;

}
{/*@bgen(jjtree) PostfixExpression */
        {
          ASTPostfixExpression jjtn003 = new ASTPostfixExpression(JJTPOSTFIXEXPRESSION);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	(
		<FAC> "("/*@bgen(jjtree) #Brackets( ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 16) */
                {
                  ASTBrackets jjtn001 = new ASTBrackets(JJTBRACKETS);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/ 
		(
			AdditiveExpression() 
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 16);
                  }
                }
/*@egen*/")"/*@bgen(jjtree) Postfix */
                {
                  ASTPostfix jjtn002 = new ASTPostfix(JJTPOSTFIX);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/ 
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn002, true);
                          jjtc002 = false;
                        }
/*@egen*/
			{
				jjtn002.setName("!");
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                  }
                }
/*@egen*/
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/
	|/*@bgen(jjtree) Expo */
        {
          ASTExpo jjtn006 = new ASTExpo(JJTEXPO);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*/
	(
		<EXPO> "("/*@bgen(jjtree) #Brackets( ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 16) */
                {
                  ASTBrackets jjtn004 = new ASTBrackets(JJTBRACKETS);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                }
                try {
/*@egen*/ 
		(
			AdditiveExpression() 
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte004) {
                  if (jjtc004) {
                    jjtree.clearNodeScope(jjtn004);
                    jjtc004 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte004 instanceof RuntimeException) {
                    throw (RuntimeException)jjte004;
                  }
                  if (jjte004 instanceof ParseException) {
                    throw (ParseException)jjte004;
                  }
                  throw (Error)jjte004;
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004,  ( ( SimpleNode ) jjtree . peekNode ( ) ) . getId ( ) < 16);
                  }
                }
/*@egen*/
		","/*@bgen(jjtree) Brackets */
                    {
                      ASTBrackets jjtn005 = new ASTBrackets(JJTBRACKETS);
                      boolean jjtc005 = true;
                      jjtree.openNodeScope(jjtn005);
                    }
                    try {
/*@egen*/ (AdditiveExpression())/*@bgen(jjtree)*/
                    } catch (Throwable jjte005) {
                      if (jjtc005) {
                        jjtree.clearNodeScope(jjtn005);
                        jjtc005 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte005 instanceof RuntimeException) {
                        throw (RuntimeException)jjte005;
                      }
                      if (jjte005 instanceof ParseException) {
                        throw (ParseException)jjte005;
                      }
                      throw (Error)jjte005;
                    } finally {
                      if (jjtc005) {
                        jjtree.closeNodeScope(jjtn005, true);
                      }
                    }
/*@egen*/ ")"
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte006) {
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte006 instanceof RuntimeException) {
            throw (RuntimeException)jjte006;
          }
          if (jjte006 instanceof ParseException) {
            throw (ParseException)jjte006;
          }
          throw (Error)jjte006;
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
          }
        }
/*@egen*/
}

void Root() : {/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Root */
        try {
/*@egen*/
	(
		<SQRT>
		"(" AdditiveExpression() ")"/*@bgen(jjtree) Number */
                {
                  ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/
			{jjtn001.setName("2");}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/
	)
	|
	<ROOT>
	"(" AdditiveExpression() "," AdditiveExpression() ")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * spezieller Ausdruck zur Definition von Vektoren und Matrizen 
*/
void VecmathDefinition() : {/*@bgen(jjtree) VecmathDefinition */
        ASTVecmathDefinition jjtn000 = new ASTVecmathDefinition(JJTVECMATHDEFINITION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int test;
	int test2;
	Token type;

}
{/*@bgen(jjtree) VecmathDefinition */
        try {
/*@egen*/
	type= <VECMATH> 
	{
		jjtn000.setName(type.image);
	}
	"("
	
	(
		LOOKAHEAD(2)
		"{"test= Braces() "}"
		|
		(
			"{""{"
			test= Braces()
			"}"
			(
				",""{" test2= Braces() "}"
				{
					if (test != test2) 
					{
						throw new ParseException(
							"Ungleiche Spalten bei Matrix in Zeile: " + token.next.beginLine);
					}
				}
			)*
			"}"
		)
	)
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/*
 * Ausdruck f\u00fcr alle funktionen mit mehreren parametern: z.b. f(x,y)
*/
void EvalStep()       : {}
{/*@bgen(jjtree) Brackets */
        {
          ASTBrackets jjtn002 = new ASTBrackets(JJTBRACKETS);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	(/*@bgen(jjtree) #ListedExpressions(> 1) */
                {
                  ASTListedExpressions jjtn001 = new ASTListedExpressions(JJTLISTEDEXPRESSIONS);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(
			"(" RelationExpression() 
			(
				"," RelationExpression() 
			)*
			")" 
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
                }
/*@egen*/ 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/
}

/*
 * wird zur Definition von Vektoren und Matrizen verwendet "{...}"
 */
int Braces() : {/*@bgen(jjtree) Braces */
        ASTBraces jjtn000 = new ASTBraces(JJTBRACES);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int counter= 1;
}
{/*@bgen(jjtree) Braces */
        try {
/*@egen*/
	RelationExpression() 
	(
		"," RelationExpression() 
		{
			counter++;
		}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{
		return counter;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * Ausdruck f\u00fcr terme mit Index. Besteht aus:
 * - entweder einem geklammerten Ausdruck
 * - oder einer Variable
 * - und ein oder mehreren "[..]"- additiven Ausdr\u00fccken
 */
void IndexedExpression()       : {}
{/*@bgen(jjtree) #IndexedExpression(> 1) */
        {
          ASTIndexedExpression jjtn001 = new ASTIndexedExpression(JJTINDEXEDEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		Variable() 
		(Indeces())
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

/*
 * ein Indeces- Knoten
 */
void Indeces()      : {}
{/*@bgen(jjtree) Indeces */
        {
          ASTIndeces jjtn001 = new ASTIndeces(JJTINDECES);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			//IndexStep
			(
				"[" AdditiveExpression() ( "," AdditiveExpression() )* "]"
			)
			|
			// KeyWordStep
			( "." Ident() )
		)+
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	
}

/*
 * ein geklammerter Ausdruck. sowohl "(...)" als auch "|...|"
 */
void Brackets() : {/*@bgen(jjtree) Brackets */
        ASTBrackets jjtn000 = new ASTBrackets(JJTBRACKETS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Brackets */
        try {
/*@egen*/
	(
		(
			symbol= "(" Expression() ")" 
		)
		|
		(
			symbol= "|" AdditiveExpression() "|" 
		)
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(symbol.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
 * eine Variable kann sowohl ein Identifier als auch ein symbol wie gr. Buchstabe sein
 * au\u00dferdem kann es ein Nabla sein oder ein Nabla und eine variable.
 */
void Variable()       : {}
{/*@bgen(jjtree) #NablaExpression(> 1) */
        {
          ASTNablaExpression jjtn001 = new ASTNablaExpression(JJTNABLAEXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			Nabla() 
			(
				//(
				//	LOOKAHEAD(PointExpression())
				//	PointExpression() 
				//	|
				//	Ident()
				//)
				Ident()
				|
				Symbol() 
				|
				UndefinedVector() 
				|
				VecmathSymbol() 
				|
				UndefinedMatrix()
			)?
		)
		|
		(
			//(
				//	LOOKAHEAD(PointExpression())
				//	PointExpression() 
				//	|
				//	Ident()
				//)
			Ident()
			|
			Symbol() 
			|
			UndefinedVector() 
			|
			VecmathSymbol() 
			|
			UndefinedMatrix()
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

void VecmathSymbol() : {/*@bgen(jjtree) VecmathSymbol */
        ASTVecmathSymbol jjtn000 = new ASTVecmathSymbol(JJTVECMATHSYMBOL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) VecmathSymbol */
        try {
/*@egen*/
	(
		t= "<vektor>" 
		{
			jjtn000.setName(t.image);
		}
		|
		t= "<dualvektor>" 
		{
			jjtn000.setName(t.image);
		}
		|
		t= "<matrix>" 
		{
			jjtn000.setName(t.image);
		}
	)
	Ident()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void UndefinedVector() : {/*@bgen(jjtree) UndefinedVector */
        ASTUndefinedVector jjtn000 = new ASTUndefinedVector(JJTUNDEFINEDVECTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	Token t2;
}
{/*@bgen(jjtree) UndefinedVector */
        try {
/*@egen*/
	t= <UNDEFVECTOR> 
	{
		jjtn000.setName(t.image);
	}
	(/*@bgen(jjtree) Number */
                {
                  ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(
			(
				t2= <INTEGER_LITERAL> 
				|
				t2= <IDENTIFIER> 
			)/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/
			{
				jjtn001.setName(t2.image);
			}
		)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/
	)
	")>" Ident()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}


  //erstellt eine matrix mit werten vom Typ m[1][1],m[1][2],...,m[1][n],m[2][1],...m[n][k];
void UndefinedMatrix() : {/*@bgen(jjtree) UndefinedMatrix */
        ASTUndefinedMatrix jjtn000 = new ASTUndefinedMatrix(JJTUNDEFINEDMATRIX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}
{/*@bgen(jjtree) UndefinedMatrix */
        try {
/*@egen*/
	<UNDEFMATRIX>/*@bgen(jjtree) Number */
        {
          ASTNumber jjtn001 = new ASTNumber(JJTNUMBER);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		(
			t= <INTEGER_LITERAL> 
			|
			t= <IDENTIFIER> 
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/
		{
			jjtn001.setName(t.image);
		}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/","/*@bgen(jjtree) Number */
        {
          ASTNumber jjtn002 = new ASTNumber(JJTNUMBER);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ 
	(
		(
			t= <INTEGER_LITERAL> 
			|
			t= <IDENTIFIER> 
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002, true);
                  jjtc002 = false;
                }
/*@egen*/
		{
			jjtn002.setName(t.image);
		}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/")>" Ident()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void PointExpression()      :{
	Token t;
	String s;
}
{/*@bgen(jjtree) Ident */
        {
          ASTIdent jjtn001 = new ASTIdent(JJTIDENT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		
		t= <IDENTIFIER> 
		{
			s=t.image;
		}
		"."
		(
			t= <INTEGER_LITERAL>
			|
			t= <IDENTIFIER> 
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/
		{
			s+="."+t.image;
			jjtn001.setName(s);
		}
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
}

void Ident() : {/*@bgen(jjtree) Ident */
        ASTIdent jjtn000 = new ASTIdent(JJTIDENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token t;
	String s;

}
{/*@bgen(jjtree) Ident */
        try {
/*@egen*/
	t= <IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{
		jjtn000.setName(t.image);
		Map m = (Map)modifierMap.get(t.image);
		if(m!=null){
			jjtn000.setModifier(m);
			jjtn000.setBroker(broker);
		}
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

void Number() : {/*@bgen(jjtree) Number */
        ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Number */
        try {
/*@egen*/
	(
		symbol= <INFIN> 
		|
		symbol= <EULER> 
		|
		symbol= <PI> 
		|
		symbol= <FLOAT_LITERAL> 
		|
		symbol= <INTEGER_LITERAL> 
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{

		jjtn000.setName(symbol.image);

	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Symbol() : {/*@bgen(jjtree) Symbol */
        ASTSymbol jjtn000 = new ASTSymbol(JJTSYMBOL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/

	Token symbol;

}
{/*@bgen(jjtree) Symbol */
        try {
/*@egen*/
	symbol= <SYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{

		jjtn000.setName(symbol.image);

	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
