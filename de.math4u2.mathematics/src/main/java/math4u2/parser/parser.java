/* Generated By:JavaCC: Do not edit this line. parser.java */
package math4u2.parser;

import math4u2.mathematics.functions.*;
import math4u2.mathematics.termnodes.*;
import math4u2.mathematics.results.*;
import math4u2.mathematics.types.*;
import math4u2.application.MainWindow;
import math4u2.controller.*;
import math4u2.controller.reference.*;
import math4u2.mathematics.affine.*;
import math4u2.mathematics.affine.Map;
import math4u2.mathematics.collection.*;

import java.util.*;
import java.io.StringReader;
import math4u2.mathematics.types.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import math4u2.parser.importdata.*;
import math4u2.util.exception.ExceptionManager;
import math4u2.util.exception.parser.*;
import math4u2.view.gui.listview.ViewFactoryInterface;

public class parser implements parserConstants {
        static parser theOnlyParser= null;
        static Broker broker;
        static ViewFactoryInterface viewFactory;
        static String functionName; // sollte man als globale ScalarVariable beseitigen

        public static void init(Broker broker, ViewFactoryInterface viewFactory){
                parser.broker=broker;
                parser.viewFactory = viewFactory;
        }

        public static List startValidate ( String text, Broker broker, ViewFactoryInterface viewFactory ) {
                init(broker, viewFactory);

                if (theOnlyParser == null) {
                        theOnlyParser= new parser(new StringReader(text));
                } else {
                        parser.ReInit(new StringReader(text));
                }

                return new ArrayList();
        }

        public static void handleValidateError( Throwable e, List regList, Broker broker )
           throws ParseException {

                        try {
                        broker.deleteAnonymousObjects(regList);
                        }catch ( BrokerException be) {
                ExceptionManager.doError("Fehler beim Loeschen der temporaer erzeugten Objekte",be);
            }
                        if (e instanceof ParseException){
                                //System.out.println("Parse-Exc col " + ((ParseException)e).getErrorColumn());
                                throw (ParseException)e;
                        }
                        if (e instanceof TokenMgrError){
                                throw new ParseException(((TokenMgrError) e).getErrorColumn(), e.getMessage(), e);
                        }
                        if (token != null){
                                throw new ParseException(token.beginColumn, e.getMessage(), e);
                        }
                        throw new ParseException(e);

        }



        public static void validatePoint( String text, Broker broker ) throws ParseException {
                init(broker, viewFactory);
                Object def;
                List regList = new ArrayList();


                if (theOnlyParser == null) {
                        theOnlyParser= new parser(new StringReader(text));
                } else {
                        parser.ReInit(new StringReader(text));
                }

                try {
                        def=parser.newPointObject(regList);
                } catch (Throwable e) {
                        // die neu erzeugten Objekte werden geloescht
                        try {
                        broker.deleteAnonymousObjects(regList);
                        }catch ( BrokerException be) {
                ExceptionManager.doError("Fehler beim Loeschen der temporaer erzeugten Objekte",be);
            }
                        if (e instanceof ParseException){
                                //System.out.println("Parse-Exc col " + ((ParseException)e).getErrorColumn());
                                throw (ParseException)e;
                        }
                        if (e instanceof TokenMgrError){
                                throw new ParseException(((TokenMgrError) e).getErrorColumn(), e.getMessage(), e);
                        }
                        if (token != null){
                                throw new ParseException(token.beginColumn, e.getMessage(), e);
                        }
                        throw new ParseException(e);
                }
        }


        /**
	 * Parst die in text enthaltene Definition eines Objekts und
	 * meldet sie beim Broker an.
	 * @param text  Enthaelt die Definition
	 * @param broker
	 * @return Name des definierten Objekts
	 * @throws Exception
	 */
        public static String NEWParseDefinition(String text, boolean publish, Broker broker) throws ParseException {

                // Dateipfade durch ihren Inhalt ersetzen


                Pattern pat = Pattern.compile("finput");
                Matcher mat = pat.matcher(text);

                // pruefen, ob ein Datei-Imput vorliegt, dann Ersetzung vornehmen
                if ( mat.find() ) {

                        // Gesamtstruktur testen
                        if ( ! defStrucTester.hasDefStruc(text) )
                   throw new ParseException( 0, "Fehler im Definitionsterm" );

                        // Pruefen, ob Matrix (oder vektot bzw. dualvektor )
                        boolean isMatrix = text.indexOf( "matrix" ) >= 0 ;

                        // Position des Zuweisungsoperators
                        int assingPos = text.indexOf( ":=" );
                        // Name des Objekts
                        String head = text.substring(0,assingPos );

                        // Beginn von finput
                        int startRepl = mat.start();

                        // Ende von finput
                        int startPath = mat.end();

                        // Position der schliessenden Klammer

                        int endPath = text.indexOf( ')', startPath);
                        String path;
                        // Pruefen, ob Pfadangabe vorliegt
                        if (  text.charAt( startPath ) == ':'  ) {
                                path = text.substring(startPath+1, endPath ).trim();
                        }
                        else path = "";

                        WhitespaceSeperated id = new WhitespaceSeperated();
                        id.setAllwaysMatrixResult(isMatrix);

                        try {
                                        String result = id.importFromStream(path, head, MainWindow.get());
                                        text = text.substring(0, startRepl).concat(result.concat(text.substring(endPath)));
                        }
                        catch ( Exception e ) {
                                throw new ParseException(e);
                        }
                }


                init(broker, viewFactory);
                Object def;


                if (theOnlyParser == null) {
                        theOnlyParser= new parser(new StringReader(text));
                } else {
                        parser.ReInit(new StringReader(text));
                }
                /* in regList werden die Objekte registriert, die 
		   beim Parse-Vorgang neu erzeugt werden. */
                List regList = new ArrayList();
                try {
                        def=parser.definition(regList, publish, broker);
                } catch (Throwable e) {
                        // die neu erzeugten Objekte werden geloescht
                        try {
                        broker.deleteAnonymousObjects(regList);
                        }catch ( BrokerException be) {
                ExceptionManager.doError("Fehler beim Loeschen der temporaer erzeugten Objekte",be);
            }
                        if (e instanceof ParseException){
                                //System.out.println("Parse-Exc col " + ((ParseException)e).getErrorColumn());
                                throw (ParseException)e;
                        }
                        if (e instanceof TokenMgrError){
                                throw new ParseException(((TokenMgrError) e).getErrorColumn(), e.getMessage(), e);
                        }
                        if (token != null){
                                throw new ParseException(token.beginColumn, e.getMessage(), e);
                        }
                        throw new ParseException(e);
                }

                //Wenn ein Unterobjekt redefiniert wurde z.B. p.x,
                //weiﬂ das Object mit getKey() nicht ihren namen
                if(def instanceof String){
                        return (String)def;
                }

                return (String) (((MathObject)def).getIdentifier());
        }

        public static TermNode parsePath(String text, Broker broker) throws ParseException {
                init(broker, viewFactory);
                TermNode path = null;

                if (theOnlyParser == null) {
                        theOnlyParser= new parser(new StringReader(text));
                } else {
                        parser.ReInit(new StringReader(text));
                }

                try {
                        path=parser.methodPath(new ArrayList(), new ArrayList(), new HashSet(), new ArrayList());

                }
                catch( Exception e ) {
                                        throw new ParseException("Fehler beim Parsen eines Pfades in der Definition "+text);
                }
                return path;

        }



        static UserFunction objectToUserFunction( MathObject mo, List regList, Broker broker ) {
                        TermNode rTerm = new PathReference(mo, new LinkedList(),  broker);
                        UserFunction rFunction= new UserFunction(rTerm, new ScalarVariable[0], broker, viewFactory);
                                List temp = new ArrayList();
                                temp.add(mo);
                                try {
                                   UserFunction.register(rFunction, new ArrayList(temp), regList, broker);
                                }
                                catch( BrokerException e ) {
                                        ExceptionManager.doError("Fehler beim Erzeugen der Funktion "+rFunction.getIdentifier(), e);
                                }
                        regList.add(rFunction);
                        return rFunction;
        }

  static final public Object definition(List regList, boolean publish, Broker broker) throws ParseException, Exception {
        Object defHead;
        MathObject mo;
        List vars= new ArrayList();
        List varNames= new ArrayList();
    List headerRegList = new ArrayList();
    defHead = definitionHeaderPath(headerRegList);
    variableDeclaration(vars, varNames);
    jj_consume_token(ASSIGN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      mo = functionDefinitionBody(vars, varNames, regList);
      break;
    case CURVE:
    case COMPOUNDCURVE:
    case POINT:
    case MARKER:
    case BAR:
    case DISCRETE:
    case DISCRETESEQ:
    case FIELD:
    case TEXTELEMENT:
    case AREA:
    case PFEIL:
    case STRETCH:
    case BEZIER:
    case CIRCLE:
    case ANGLE:
    case STRAIGHT:
    case KARTE:
      mo = keywordDefinitionBody(regList);
      break;
    case LT:
    case SEQUENCE:
    case SEQUENCE0:
      if (jj_2_1(2)) {
        mo = listDefinitionBody(regList);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
        case SEQUENCE:
        case SEQUENCE0:
          mo = sequenceDefinitionBody(defHead, vars, regList);
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
                if(defHead instanceof String) {
                         if ( publish ) {
                                broker.publishObject(mo, defHead.toString());
                         }

                         {if (true) return mo;}
                }else{
                         MathObject rpo = (MathObject) ((Object[])defHead)[0];
                         List methods = (List) ((Object[])defHead)[1];

                         //Erzeuge den Schl¸ssel
                         String key = rpo.getIdentifier()+"";
                         Iterator iter = methods.iterator();
                         while(iter.hasNext()){
                                if(iter.hasNext()) key += ".";
                                key += ((MethodContext)iter.next()).getMethodName();
                        }

                         MethodContext lastMethod = (MethodContext)methods.get(methods.size()-1);
                         lastMethod.setMethodName("set_"+lastMethod.getMethodName());

                         List moMethods = new LinkedList();
                         if(mo instanceof UserFunction){
                                moMethods.add(new MethodContext("funktion"));
                        }else{
                                PathReference pr = new PathReference(mo,new LinkedList(), broker);
                                mo = new UserFunction(pr, new Variable[0],broker, viewFactory);
                        }//else
                         lastMethod.setArgs(new TermNode[]{new PathReference(mo, moMethods, broker)});

                         //hier wird die Set-Methode aufgerufen
                         PathReference pr = new PathReference( rpo, methods, broker );

                         //Verˆffentlichen, damit die Redefinition mit swaplinks anl‰uft
                         if ( publish ) {
                                broker.publishObject(mo,key);
                         }
                        {if (true) return key;}
                }
    throw new Error("Missing return statement in function");
  }

/* Liest eine Variablendeklaration wie in g(x):= ...
   das (x) oder in  f(<vektor>x, <vektor>y):= das (<vektor>x, <vektor>y)
   fuegt an vars saemtliche Variablen an
   und an varNames die entsprechenden Namen.
   Wenn keine Variable deklariert wird (nullstellige Funktion),
   dann kann dies durch die leere Variablenklammer erfolgen, also z.B.
   a():=3
   oder dadurch, dass die Deklaration ganz entfaellt:
   b:= 4 */
  static final public void variableDeclaration(List vars, List varNames) throws ParseException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 60:
      jj_consume_token(60);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case Bezeichner:
        oneVariableDeclaration(vars, varNames);
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 61:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_1;
          }
          jj_consume_token(61);
          oneVariableDeclaration(vars, varNames);
        }
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      jj_consume_token(62);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
  }

/* Liest die Deklaration einer Variablen wie in g(x)
   das x oder in  f(<vektor>x, <vektor>y) das <vektor>y,
   fuegt an vars die entsprechende Variable an
   und an varNames den entsprechenden Namen. */
  static final public void oneVariableDeclaration(List vars, List varNames) throws ParseException, Exception {
  int type = SCALAR;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      jj_consume_token(LT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCALAR:
        jj_consume_token(SCALAR);
        break;
      case MATRIX:
        jj_consume_token(MATRIX);
                  type = MATRIX;
        break;
      case VECTOR:
        jj_consume_token(VECTOR);
                  type = VECTOR;
        break;
      case DUALVECTOR:
        jj_consume_token(DUALVECTOR);
                      type = DUALVECTOR;
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(GT);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(Bezeichner);
      for (int i= 0; i < varNames.size(); i++) {
        if (token.image.compareTo((String) (varNames.get(i))) == 0)
          {if (true) throw new ParseException( token.beginColumn,
                                    "Variable mit Namen  \"" + token.image + "\" kommt mehrfach vor");}
        }
      varNames.add(token.image);
      switch( type ) {
        case SCALAR : {
          vars.add(new ScalarVariable(token.image));
          break;
        }
        case MATRIX : {
          vars.add(new MatrixVariable(token.image));
          break;
        }
        case VECTOR : {
          vars.add(new VectorVariable(token.image));
          break;
        }
        case DUALVECTOR : {
          vars.add(new DualVectorVariable(token.image));
          break;
        }
      }
  }

/**
 * Parst Einen Term in Operatorschreibweise der die Infix-Operatoren "+" und "-"
 * und alle anderen Operatoren mit hoeherer Bindungsst‰rke enthaelt.
 * varNames enth‰lt die Namen (Strings) der Variablen,
 * die vorkommen d¸rfen, vars die entsprechenden Variablen(-Objekte).
 * In refObjPaths werden die Pfade der Objekte (Funktionen, ...) eingef¸gt,
 * die verwendet werden.
 * @param vars
 * @param varNames
 * @param refObjPaths
 * @return
 * @throws Exception
 */
  static final public TermNode sum(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        Token x;
        TermNode firstTerm, secondTerm;
    firstTerm = signedTerm(vars, varNames, refObjPaths, regList);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        x = jj_consume_token(PLUS);
        break;
      case MINUS:
        x = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      secondTerm = term(vars, varNames, refObjPaths, regList);
                    switch( x.kind ) {
                      case PLUS : {
                         Function func = OperatorExpert.getFunctionForArguments( firstTerm,
                                                  secondTerm,
                                                  x.image,
                                                  broker );
                         firstTerm = new TermNodeFunct( func,
                                                         new TermNode [] { firstTerm, secondTerm },
                                                         broker );
                         break;
                      }
                      case MINUS : {
                         Function func = OperatorExpert.getFunctionForArguments( firstTerm,
                                                  secondTerm,
                                                  x.image,
                                                  broker );
                         firstTerm = new TermNodeFunct( func,
                                                        new TermNode [] { firstTerm, secondTerm },
                                                        broker );
                         break;
                      }
                    }
    }
                {if (true) return firstTerm;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parst in einem Term den ersten Summanden, der gegebenenfalls
 * ein Vorzeichen "-" haben kann.
 */
  static final public TermNode signedTerm(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        TermNode firstTerm;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
      jj_consume_token(MINUS);
      firstTerm = term(vars, varNames, refObjPaths, regList);
                if (firstTerm instanceof TermNodeNum) {
                        firstTerm= new TermNodeNum(-1 * firstTerm.evalScalar());
                }
        else {
            Function func = OperatorExpert.getFunctionForArgument( firstTerm, "-", broker );
                        firstTerm = new TermNodeFunct( func, new TermNode [] { firstTerm }, broker );
                }
                {if (true) return firstTerm;}
      break;
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      firstTerm = term(vars, varNames, refObjPaths, regList);
                {if (true) return firstTerm;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parst einen Term in Operatorschreibweise der die Infix-Operatoren "*" und "/"
 * und alle anderen Operatoren mit hoeherer Bindungsst‰rke enthaelt.
 * Sonst wie sum()
 */
  static final public TermNode term(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
   Token x = null;
   int kind = 0;
   TermNode firstTerm, secondTerm;
    firstTerm = exp(vars, varNames, refObjPaths, regList);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case LT:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        x = jj_consume_token(MULTIPLY);
             kind = x.kind;
        break;
      case LT:
        jj_consume_token(LT);
        jj_consume_token(MULTIPLY);
        jj_consume_token(GT);
             kind = SCALARPRODUCT;
        break;
      case DIVIDE:
        x = jj_consume_token(DIVIDE);
             kind = x.kind;
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      secondTerm = exp(vars, varNames, refObjPaths, regList);
           switch ( kind ) {
             case MULTIPLY : {
                Function func = OperatorExpert.getFunctionForArguments( firstTerm,
                                                  secondTerm,
                                                  x.image,
                                                  broker );
                firstTerm = new TermNodeFunct(
                          func,
                          new TermNode [] { firstTerm, secondTerm },
                          broker );
                break;
             }
             case SCALARPRODUCT : {
               firstTerm = new TermNodeFunct(
                          (Function)(broker.getObject("ScalarProd")),
                          new TermNode [] { firstTerm, secondTerm },
                          broker );
                break;
             }
             case DIVIDE : {
                 Function func = OperatorExpert.getFunctionForArguments( firstTerm,
                                                  secondTerm,
                                                  x.image,
                                                  broker );
                firstTerm = new TermNodeFunct(
                          func,
                          new TermNode [] { firstTerm, secondTerm },
                          broker );
                break;
             }
           }
    }
     {if (true) return firstTerm;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parst einen Term in Operatorschreibweise der den Infix-Operator "^" und
 * alle anderen Operatoren mit hoeherer Bindungsst‰rke enthaelt.
 * Sonst wie sum()
 */
  static final public TermNode exp(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        TermNode firstTerm, secondTerm;
    firstTerm = fac(vars, varNames, refObjPaths, regList);
    label_4:
    while (true) {
      if (jj_2_2(2147483647)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(EXP);
      secondTerm = exp(vars, varNames, refObjPaths, regList);
                        firstTerm= new TermNodeFunct(
                                        (Function) (broker.getObject("pow")),
                                        new TermNode[] { firstTerm, secondTerm },
                                        broker);
    }
                {if (true) return firstTerm;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parst einen Term in Operatorschreibweise der den Postfix-Operator "!" enthaelt.
 * Sonst wie sum()
 */
  static final public TermNode fac(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        TermNode firstTerm;
    firstTerm = element(vars, varNames, refObjPaths, regList);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FAC:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      jj_consume_token(FAC);
                        firstTerm=
                                new TermNodeFunct(
                                        (Function) (broker.getObject("fac")),
                                        new TermNode[] { firstTerm },
                                        broker);
    }
                {if (true) return firstTerm;}
    throw new Error("Missing return statement in function");
  }

/* Liest eine Gleitpunktzahl */
  static final public TermNode zahl() throws ParseException, Exception {
        TermNode term = null;
    jj_consume_token(Zahl);
              try { term= new TermNodeNum(Double.valueOf(token.image).doubleValue());
                }
                catch (NumberFormatException e) {
                   {if (true) throw new ParseException(token.beginColumn, e.toString());}
                }
                {if (true) return term;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parst folgende Teile eines Terms:
 * -- Zahlen
 * -- Funktionsaufrufe wie cos(1+x) oder strecke.begin.x
 * -- Geklammerte Terme wie ( 1+sin(x) )
 * -- Betraege wie | -3 +sin(x) |
 */
  static final public TermNode element(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        TermNode term = null, term1 = null;;
        TermNode colIndexTerm = null;
        TermNode rowIndexTerm = null;
        int indexCount = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Zahl:
      jj_consume_token(Zahl);
              try { term= new TermNodeNum(Double.valueOf(token.image).doubleValue());
                }
                catch (NumberFormatException e) {
                   {if (true) throw new ParseException(token.beginColumn, e.toString());}
                }
                {if (true) return term;}
      break;
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Bezeichner:
      term = function(vars, varNames, refObjPaths, regList);
              {if (true) return term;}
      break;
    case 60:
      jj_consume_token(60);
      term1 = sum(vars, varNames, refObjPaths, regList);
      jj_consume_token(62);
              term = new TermNodeFunct((Function) (broker.getObject("brackets")),
                                        new TermNode[] { term1 },
                                        broker);
              indexCount = 0;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 63:
        jj_consume_token(63);
        rowIndexTerm = sum(vars, varNames, refObjPaths, regList);
                indexCount = 1;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 61:
          jj_consume_token(61);
          colIndexTerm = sum(vars, varNames, refObjPaths, regList);
                   indexCount = 2;
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        jj_consume_token(64);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
             // brackets-Funktion holen
             RootPathObject rpo  = (Function) (broker.getObject("brackets"));

             // erster Schritt: eval mit term

             MethodContext mc1 = new MethodContext("calceval", new TermNode [] {term1});

             // zweiter Schritt: index mit rowIndexTerm, colIndexTerm
             /*
               TermNode[] arguments = new TermNode[argList.size()];
                arguments = (TermNode[]) argList.toArray(arguments);

             */
             // pr = new PathReference( rpo, methods, broker );
             MethodContext mc2 = null;

             switch ( indexCount ) {
                   case 0 : {
                      {if (true) return term;}
                   }
                   case 1 : {
                       mc2 = new MethodContext("index", new TermNode[] {rowIndexTerm}); break;
                   }
                   case 2 : {
                       mc2 = new MethodContext("index", new TermNode[] {rowIndexTerm, colIndexTerm}); break;
                   }
                }
                List steps = new ArrayList();
                steps.add(mc1);
                steps.add(mc2);
                {if (true) return new PathReference( rpo, steps, broker );}
      break;
    case 65:
      jj_consume_token(65);
      term = sum(vars, varNames, refObjPaths, regList);
      jj_consume_token(65);
                    if ( ScalarType.class.isAssignableFrom(term.getResultType()) )
                       {if (true) return new TermNodeFunct((Function) (broker.getObject("abs")), new TermNode[] { term }, broker);}
                    else
                       {if (true) return new TermNodeFunct((Function) (broker.getObject("norm")), new TermNode[] { term }, broker);}
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parst Funktionsaufrufe (nicht in Operatorschreibweise) und erzeugt den
 * entsprechenden Termnode. varNames enth‰lt die Namen (Strings) der Variablen, die
 * in den Argumenttermen vorkommen d¸rfen, vars die entsprechenden
 * Variablen(-Objekte).
 * In refObjPaths werden die Pfade der Objekte eingef¸gt, die in den
 * Argumenttermen verwendet werden.
 */
  static final public TermNode function(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        TermNode term = null, term1, term2, colIndexTerm = null,  rowIndexTerm = null, deriveOrderTerm = null;
        String funcname;
        Function fkt = null;
        int arity;
    int indexCount;
        Set localRefObjPaths;
        List localVarNames, localVars, diffVars, argList = null;
        UserFunction localFunction;
        TermNode[] arguments= null;
        TermNode inTerm;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
      /* Definition einer Matrix oder eines Vektors */
             inTerm = matrixNodeDefinition(vars, varNames, refObjPaths, regList);
           {if (true) return inTerm;}
      break;
    case SUM:
    case PRODUCT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUM:
        jj_consume_token(SUM);
        break;
      case PRODUCT:
        jj_consume_token(PRODUCT);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                funcname= token.image;
      term = iteratorBody(funcname, vars, varNames, refObjPaths, regList);
                {if (true) return term;}
      break;
    default:
      jj_la1[26] = jj_gen;
      if (jj_2_3(2)) {
        term = methodPath(vars, varNames, refObjPaths, regList);
                {if (true) return term;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DERIVE:
          jj_consume_token(DERIVE);
          jj_consume_token(60);
             localVarNames = varNames;
             localVars = vars;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case VARS:
            jj_consume_token(VARS);
                  localVarNames = new ArrayList();
                  localVars = new ArrayList();
            variableDeclaration(localVars, localVarNames);
            jj_consume_token(61);
            break;
          default:
            jj_la1[17] = jj_gen;
            ;
          }
               if ( localVarNames.size() != 1 ) {
                  {if (true) throw new Exception( "Keine oder mehr als eine Variable bei Ableitung");}
               }
               if ( ! (localVars.get(0) instanceof ScalarVariable) ) {
                  {if (true) throw new Exception( "Variable, nach der abgeleitet werden soll, ist nicht vom Typ Skalar");}
               }
               localRefObjPaths= new HashSet();
               diffVars = new ArrayList();
               diffVars.add(new ScalarVariable((String)(localVarNames.get(0))));
               List localRegList = new ArrayList();
               Set localRefObjectPaths = new HashSet();
          term = sum(diffVars, localVarNames, localRefObjPaths, localRegList);
                UserFunction f = new UserFunction( term, new ScalarVariable[] {(ScalarVariable) (diffVars.get(0))},broker, viewFactory);
                f.register(f, new ArrayList(localRefObjPaths), localRegList, broker );
                regList.add(f);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 61:
            jj_consume_token(61);
            deriveOrderTerm = sum(vars, varNames, refObjPaths, regList);
            break;
          default:
            jj_la1[18] = jj_gen;
            ;
          }
                if( deriveOrderTerm == null ) {
                        deriveOrderTerm = new TermNodeNum(1.0);
                }
          jj_consume_token(62);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 60:
            jj_consume_token(60);
                   arguments= null;
                   argList = new ArrayList();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MINUS:
            case SUM:
            case PRODUCT:
            case DERIVE:
            case PDERIVE:
            case MATRIX:
            case DIAGMATRIX:
            case EMATRIX:
            case VECTOR:
            case DUALVECTOR:
            case Zahl:
            case Bezeichner:
            case 60:
            case 65:
              term = sum(vars, varNames, refObjPaths, regList);
                           argList.add(term);
              label_6:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case 61:
                  ;
                  break;
                default:
                  jj_la1[19] = jj_gen;
                  break label_6;
                }
                jj_consume_token(61);
                term = sum(vars, varNames, refObjPaths, regList);
                              argList.add(term);
              }
              break;
            default:
              jj_la1[20] = jj_gen;
              ;
            }
                        arguments= new TermNode[argList.size()];
                        argList.toArray(arguments);
            jj_consume_token(62);
            break;
          default:
            jj_la1[21] = jj_gen;
            ;
          }
                refObjPaths.add(f);
                if (arguments == null) {
                        arguments= new TermNode[vars.size()];
                        vars.toArray(arguments);
                }
                {if (true) return new TermNodeDerive(f, deriveOrderTerm, arguments, broker);}
          break;
        case PDERIVE:
          jj_consume_token(PDERIVE);
          jj_consume_token(60);
           localVarNames = varNames;
             localVars = vars;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case VARS:
            jj_consume_token(VARS);
                  localVarNames = new ArrayList();
                  localVars = new ArrayList();
            variableDeclaration(localVars, localVarNames);
            jj_consume_token(61);
            break;
          default:
            jj_la1[22] = jj_gen;
            ;
          }
                localRefObjPaths= new HashSet();
                diffVars= new ArrayList();

                for (int i= 0; i < localVarNames.size(); i++)
                        diffVars.add(new ScalarVariable((String) (localVarNames.get(i))));
          localFunction = pDeriveBody(diffVars, localVarNames, localRefObjPaths, regList);
                UserFunction.register(localFunction, new ArrayList(localRefObjPaths), regList, broker);
          jj_consume_token(62);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 60:
            jj_consume_token(60);
                   arguments= null;
                   argList = new ArrayList();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MINUS:
            case SUM:
            case PRODUCT:
            case DERIVE:
            case PDERIVE:
            case MATRIX:
            case DIAGMATRIX:
            case EMATRIX:
            case VECTOR:
            case DUALVECTOR:
            case Zahl:
            case Bezeichner:
            case 60:
            case 65:
              term = sum(vars, varNames, refObjPaths, regList);
                                argList.add(term);
              label_7:
              while (true) {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case 61:
                  ;
                  break;
                default:
                  jj_la1[23] = jj_gen;
                  break label_7;
                }
                jj_consume_token(61);
                term = sum(vars, varNames, refObjPaths, regList);
                                        argList.add(term);
              }
              break;
            default:
              jj_la1[24] = jj_gen;
              ;
            }
                        arguments= new TermNode[argList.size()];
                        argList.toArray(arguments);
            jj_consume_token(62);
            break;
          default:
            jj_la1[25] = jj_gen;
            ;
          }
                refObjPaths.add(localFunction);
                if (arguments == null) {
                        arguments= new TermNode[vars.size()];
                        vars.toArray(arguments);
                }
                {if (true) return new TermNodeFunct(localFunction, arguments, broker);}
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public MethodContext evalStep(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        TermNode term;
        List argList = new ArrayList();
    jj_consume_token(60);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      term = sum(vars, varNames, refObjPaths, regList);
                    argList.add(term);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 61:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_8;
        }
        jj_consume_token(61);
        term = sum(vars, varNames, refObjPaths, regList);
                           argList.add(term);
      }
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    jj_consume_token(62);
                TermNode[] arguments = new TermNode[argList.size()];
                argList.toArray(arguments);
                {if (true) return new MethodContext("calceval", arguments);}
    throw new Error("Missing return statement in function");
  }

  static final public MethodContext indexStep(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        TermNode term;
        List argList = new ArrayList();
    jj_consume_token(63);
    term = sum(vars, varNames, refObjPaths, regList);
             argList.add(term);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 61:
      jj_consume_token(61);
      term = sum(vars, varNames, refObjPaths, regList);
             argList.add(term);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    jj_consume_token(64);
                TermNode[] arguments = new TermNode[argList.size()];
                arguments = (TermNode[]) argList.toArray(arguments);
                {if (true) return new MethodContext("index", arguments);}
    throw new Error("Missing return statement in function");
  }

  static final public MethodContext keyWordStep(List vars, List varNames, Set refObjPaths) throws ParseException, Exception {
TermNode term;
        List argList = new ArrayList();
        String methodName=null;
    jj_consume_token(66);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Bezeichner:
      jj_consume_token(Bezeichner);
      break;
    case VECTOR:
      jj_consume_token(VECTOR);
      break;
    case AREA:
      jj_consume_token(AREA);
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      break;
    case POINT:
      jj_consume_token(POINT);
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                methodName = token.image;
               {if (true) return new MethodContext(methodName, new TermNode[0] );}
    throw new Error("Missing return statement in function");
  }

  static final public TermNode methodPath(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        List methods = new ArrayList();
        String funcname;
        boolean isVar;
        MethodContext mc;
        MathObject root = null;
        Variable term = null;
        RootPathObject rpo = null;
    jj_consume_token(Bezeichner);
            funcname = token.image;
            isVar = false;
                for (int i= 0; i < varNames.size(); i++) {
                                       if (funcname.compareTo((String)varNames.get(i)) == 0) {
                           term = (Variable) (vars.get(i));
                           isVar = true;
                           break;
                        }
                }
                if(isVar){
                     rpo= term;
                      // fkt =  (MathObject)broker.tryToGetObject("identity");
                     // methods.add(new MethodContext("eval", new TermNode[]{ term}));
                }
                else{
                         rpo=  (MathObject)broker.tryToGetObject(funcname);

                        if(rpo instanceof UserDefinedFunction){
                                try {
                                         rpo = (RootPathObject) rpo.getClass().newInstance();
                                } catch (InstantiationException e) {
                                        ExceptionManager.doError(e);
                                } catch (IllegalAccessException e) {
                                        ExceptionManager.doError(e);
                                }
                        }

                         //refObjPaths.add(new MathObjectPath((MathObject)rpo, funcname));
                         refObjPaths.add((MathObject)rpo);
                }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 60:
      case 63:
      case 66:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 60:
        mc = evalStep(vars, varNames, refObjPaths, regList);
              methods.add(mc) ;
        break;
      case 63:
        mc = indexStep(vars, varNames, refObjPaths, regList);
              methods.add(mc) ;
        break;
      case 66:
        mc = keyWordStep(vars, varNames, refObjPaths);
              methods.add(mc) ;
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
             PathReference pr;
             if(rpo==term) {
                //if ( methods.size() == 0 )
                //   return term;
                //else
                if ( methods.size() == 0 )
                   {if (true) return term;}
                else
                pr = new VarPathReference(rpo,methods, broker);
             }
             else pr = new PathReference( rpo, methods, broker );
             {if (true) return pr;}
    throw new Error("Missing return statement in function");
  }

  static final public Object definitionHeaderPath(List regList) throws ParseException, Exception {
        List methods = new ArrayList();
        String funcname;
        MethodContext mc;
        Set refObjPaths = new HashSet();
        List emptyList = new ArrayList();
        RootPathObject rpo = null;
    jj_consume_token(Bezeichner);
            funcname = token.image;
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 63:
      case 66:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 63:
        mc = indexStep(emptyList, emptyList, refObjPaths, regList);
              methods.add(mc) ;
        break;
      case 66:
        mc = keyWordStep(emptyList, emptyList, refObjPaths);
              methods.add(mc) ;
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
             /* rpo kann man nur finden, wenn
                man den Teil eines Objekts redefiniert, z.B.
                bei p.x :=3
                wenn man ein ganzes Objekt neu definiert, dann
                gibt es dieses beim Broker noch nicht.
                Die beiden Situationen unterscheiden sich dadurch, dass in
                der ersten mc die leere Liste ist, im zweiten Fall nicht */

             if(methods.isEmpty()){
                        {if (true) return funcname;}
                }else{
                         rpo =  (MathObject)broker.tryToGetObject(funcname);
                         {if (true) return new Object[]{rpo,methods};}
             }
    throw new Error("Missing return statement in function");
  }

/**
 * Parst den Inhalt eines Summen- oder Produktiterators, also
 * bei "sum(i,1,5,i^2)" den Teil "(i,1,5,i^2)".
 */
  static final public TermNode iteratorBody(String type, List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        String localVarName;
        ScalarVariable localVar;
        List localVars;
        List localVarNames;
        TermNode term, lowerBound, upperBound;
    jj_consume_token(60);
    jj_consume_token(Bezeichner);
                localVarName= token.image;
                for (int i= 0; i < varNames.size(); i++) {
                        if (localVarName.compareTo((String) (varNames.get(i))) == 0)
                                {if (true) throw new ParseException(
                                        token.beginColumn,
                                        "Variablenname \"" + localVarName + "\" bereits verwendet");}
                }
    jj_consume_token(61);
    lowerBound = sum(vars, varNames, refObjPaths, regList);
    jj_consume_token(61);
    upperBound = sum(vars, varNames, refObjPaths, regList);
                // in den beiden Listen lokale ScalarVariable anh‰ngen
                localVar= new ScalarParameter(localVarName);
                //localVar= new ScalarVariable(localVarName);
                localVars= new ArrayList(vars);
                localVars.add(localVar);
                localVarNames= new ArrayList(varNames);
                localVarNames.add(localVarName);
    jj_consume_token(61);
    term = sum(localVars, localVarNames, refObjPaths, regList);
    jj_consume_token(62);
                {if (true) return TermNodeIterator.makeIterator(type, localVar, lowerBound, upperBound, term);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newStretchObject(List regList) throws ParseException, Exception {
        UserFunction moPath;
        List parts = new ArrayList();
    jj_consume_token(STRETCH);
    jj_consume_token(60);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(62);
                MathObject part0= (UserFunction) parts.get(0);
                MathObject part1= (UserFunction) parts.get(1);
                MathObject mo= new Stretch(part0,part1, broker, viewFactory);
                Stretch.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newStretchUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newStretchObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newTextObject(List regList) throws ParseException, Exception {
        UserFunction moPath;
        List parts = new ArrayList();
        String textString, orientation;
    jj_consume_token(TEXTELEMENT);
    jj_consume_token(60);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    jj_consume_token(STRING_LITERAL);
                        textString = token.image;
                        parts.add( textString );
    jj_consume_token(61);
    jj_consume_token(Bezeichner);
                        orientation = token.image;
                        parts.add( orientation );
    jj_consume_token(62);
                MathObject part0= (UserFunction) parts.get(0);
                String part1= ((String) parts.get(1));
                String part2= ((String) parts.get(2));
                MathObject mo= new TextBubble(part0, part1, part2, broker, viewFactory);
                parts.remove(2);
                parts.remove(1);
                TextBubble.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newTextUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newTextObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newCurveObject(List regList) throws ParseException, Exception {
        UserFunction minFunction, maxFunction;
        UserFunction moPath;
        List parts = new ArrayList();
        String parameterName;
        ScalarVariable parameter;
        List localVars;
        List localVarNames;
    Set refObjPaths;
        TermNode xTerm, yTerm;
    jj_consume_token(CURVE);
    jj_consume_token(60);
    jj_consume_token(Bezeichner);
                        parameterName= token.image;
                        parameter= new ScalarVariable(parameterName);
                        localVars = new ArrayList();
                        localVarNames = new ArrayList();
    jj_consume_token(61);
    minFunction = scalarFunctionReference(regList);
                        parts.add(minFunction);
    jj_consume_token(61);
    maxFunction = scalarFunctionReference(regList);
                        parts.add(maxFunction);
    jj_consume_token(61);
                   refObjPaths= new HashSet();
                       localVars.add(parameter);
                       localVarNames.add(parameterName);
    xTerm = sum(localVars, localVarNames, refObjPaths, regList);
                        UserFunction xFunction= new UserFunction(xTerm, (ScalarVariable[]) localVars.toArray(new ScalarVariable[0]), broker, viewFactory);
                        UserFunction.register(xFunction, new ArrayList(refObjPaths), regList, broker);
                        regList.add(xFunction);
                        parts.add(xFunction);
    jj_consume_token(61);
                refObjPaths= new HashSet();
    yTerm = sum(localVars, localVarNames, refObjPaths, regList);
    jj_consume_token(62);
                        UserFunction yFunction= new UserFunction(yTerm, (ScalarVariable[]) localVars.toArray(new ScalarVariable[0]), broker, viewFactory);
                        UserFunction.register(yFunction, new ArrayList(refObjPaths), regList, broker);
                        regList.add(yFunction);
                        parts.add(yFunction);
                        MathObject low= (UserFunction) parts.get(0);
                        MathObject up= (UserFunction) parts.get(1);
            MathObject xf= (UserFunction) parts.get(2);
                        MathObject yf= (UserFunction) parts.get(3);
                        MathObject mo= new Curve(parameterName, (UserFunction)low, (UserFunction)up, (UserFunction)xf, (UserFunction)yf,  broker, viewFactory);
                        Curve.register(mo, parts, regList, broker);
                        regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newCurveUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newCurveObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newMapObject(List regList) throws ParseException, Exception {
        UserFunction moPath;
        String funcname;
        List parts = new ArrayList();
        String parameterName;
        ScalarVariable parameter;
        List localVars = new ArrayList();
        List localVarNames = new ArrayList();
    Set refObjPaths;
    Function bandVectorFunction, mapFunction, gradFunction = null;
    jj_consume_token(KARTE);
    jj_consume_token(60);
    jj_consume_token(Bezeichner);
            funcname = token.image;

                         mapFunction =  (Function)broker.tryToGetObject(funcname);
                         parts.add(mapFunction);
    jj_consume_token(61);
    bandVectorFunction = vectorFunctionReference(regList);
                   parts.add(bandVectorFunction);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 61:
      jj_consume_token(61);
      jj_consume_token(Bezeichner);
            funcname = token.image;

                         gradFunction =  (Function)broker.tryToGetObject(funcname);
                         parts.add(gradFunction);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(62);
                        MathObject mf= (UserFunction) parts.get(0);
                        MathObject bf= (UserFunction) parts.get(1);
                        MathObject mo;
                        if ( gradFunction == null ) {
                                mo= new Map((UserFunction)mf, (UserFunction)bf,  broker, viewFactory);
                                Map.register(mo, parts, regList, broker);
                        }
                        else {
                                MathObject gf= (UserFunction) parts.get(2);
                                mo= new GradMap((UserFunction)mf, (UserFunction)bf, (UserFunction)gf, broker, viewFactory);
                                GradMap.register(mo, parts, regList, broker);
                        }
                        regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newMapUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newMapObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newFieldObject(List regList) throws ParseException, Exception {
        UserFunction moPath;
        String funcname;
        List parts = new ArrayList();
        String parameterName, layoutConst = null;
        ScalarVariable parameter;
        List localVars = new ArrayList();
        List localVarNames = new ArrayList();
    Set refObjPaths;
    Function mapFunction;
        TermNode lowLimitTerm, upLimitTerm, bandTerm = null;
    jj_consume_token(FIELD);
    jj_consume_token(60);
    jj_consume_token(Bezeichner);
            funcname = token.image;

                         mapFunction =  (Function)broker.tryToGetObject(funcname);
                         parts.add(mapFunction);
    jj_consume_token(61);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = scalarFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = scalarFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = scalarFunctionReference(regList);
                   parts.add(moPath);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 61:
      jj_consume_token(61);
      jj_consume_token(Bezeichner);
                        layoutConst = token.image;
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
              if ( layoutConst == null ) {
                layoutConst = "V" ;
              }
    jj_consume_token(62);
                        MathObject mf= (Function) parts.get(0);
                        MathObject rp= (UserFunction) parts.get(1);
            MathObject xdf= (UserFunction) parts.get(2);
            MathObject ydf= (UserFunction) parts.get(3);
            MathObject cof= (UserFunction) parts.get(4);

            MathObject  mo=  new Field((Function)mf,(UserFunction)rp,
                                                (UserFunction)xdf, (UserFunction)ydf,
                                                (UserFunction)cof, layoutConst, true, broker, viewFactory);

            Field.register(mo, parts, regList, broker);

                        regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newFieldUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newFieldObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newBezierObject(List regList) throws ParseException, Exception {
        UserFunction moPath;
        List parts = new ArrayList();
    jj_consume_token(BEZIER);
    jj_consume_token(60);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(62);
                        MathObject part0= (UserFunction) parts.get(0);
                        MathObject part1= (UserFunction) parts.get(1);
                        MathObject part2= (UserFunction) parts.get(2);
                        MathObject part3= (UserFunction) parts.get(3);
                        MathObject mo= new Bezier(part0,part1, part2, part3, broker, viewFactory);
                        Bezier.register(mo, parts, regList, broker);
                        regList.add(mo);
                        {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newBezierUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newBezierObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newAngleObject(List regList) throws ParseException, Exception {
    List parts = new ArrayList();
    UserFunction moPath, pFunction;
    TermNode pTerm;
    jj_consume_token(ANGLE);
    jj_consume_token(60);
    // Punkt
            moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // erste Richtung
                 moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // zweite Richtung
                 moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // Radius
                    pFunction = scalarFunctionReference(regList);
                parts.add(pFunction);
    jj_consume_token(62);
                MathObject part0= (UserFunction) parts.get(0);
                MathObject part1= (UserFunction) parts.get(1);
                MathObject part2= (UserFunction) parts.get(2);
                MathObject part3= (UserFunction) parts.get(3);

                MathObject mo= new Angle(part0, part1, part2, part3, broker, viewFactory);
                Angle.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newAngleUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newAngleObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newArrowObject(List regList) throws ParseException, Exception {
    List parts = new ArrayList();
    UserFunction moPath;
    jj_consume_token(PFEIL);
    jj_consume_token(60);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(62);
                MathObject point= (UserFunction) parts.get(0);
                MathObject vector= (UserFunction) parts.get(1);
                MathObject mo= new Arrow(point, vector, broker, viewFactory);
                Arrow.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newArrowUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newArrowObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newAreaObject(List regList) throws ParseException, Exception {
    List parts = new ArrayList();
    UserFunction moPath;
    boolean fill;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AREA:
      jj_consume_token(AREA);
                 fill = true;
      break;
    case COMPOUNDCURVE:
      jj_consume_token(COMPOUNDCURVE);
                          fill = false;
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(60);
    jj_consume_token(67);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case CURVE:
    case POINT:
    case STRETCH:
    case BEZIER:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      areaElement(parts, regList);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 61:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_11;
        }
        jj_consume_token(61);
        areaElement(parts, regList);
      }
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    jj_consume_token(68);
    jj_consume_token(62);
        MathObject[] list2 = new MathObject[parts.size()];
        for (int i = 0; i < list2.length; i++) {
                        list2[i] = (UserFunction)parts.get(i);
                }//for
                MathObject mo= new Area(list2, fill, broker, viewFactory);
                Area.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newAreaUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newAreaObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newBarObject(List regList) throws ParseException, Exception {
    List parts = new ArrayList();
    UserFunction moPath;
    jj_consume_token(BAR);
    jj_consume_token(60);
    // x-Vektor
                 moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // y-Vektor
                 moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 61:
      jj_consume_token(61);
      // Dicke
                   moPath = scalarFunctionReference(regList);
                   parts.add(moPath);
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    jj_consume_token(62);
                MathObject part0= (UserFunction) parts.get(0);
                MathObject part1= (UserFunction) parts.get(1);
                MathObject part2, mo;

                if ( parts.size() == 2 ) {
                        part2= new UserFunction(new TermNodeNum(-1), new ScalarVariable[0], broker, viewFactory);
                        regList.add(part2);
                        parts.add(part2);
                }

                part2= (UserFunction) parts.get(2);

                mo= new Bar(part0, part1, part2, broker, viewFactory);
                Bar.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newBarUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newBarObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newDiscreteObject(List regList) throws ParseException, Exception {
    List parts = new ArrayList();
    UserFunction moPath;
    jj_consume_token(DISCRETE);
    jj_consume_token(60);
    // x-Vektor
                 moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // y-Vektor
                 moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // radius-Funktion
                 moPath = scalarFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(62);
                MathObject part0= (UserFunction) parts.get(0);
                MathObject part1= (UserFunction) parts.get(1);
                MathObject part2= (UserFunction) parts.get(2);

                MathObject mo= new Discrete(part0, part1, part2, broker, viewFactory);
                Discrete.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newDiscreteUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newDiscreteObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newDiscreteSequenceObject(List regList) throws ParseException, Exception {
    List parts = new ArrayList();
    UserFunction moPath;
    String layoutConst = null;
    jj_consume_token(DISCRETESEQ);
    jj_consume_token(60);
    // x-Folge
                 moPath = generalFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // y-Folge
                 moPath = generalFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // Index-Funktion
                 moPath = generalFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    // radius-Funktion
                 moPath = generalFunctionReference(regList);
                   parts.add(moPath);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 61:
      jj_consume_token(61);
      jj_consume_token(Bezeichner);
                        layoutConst = token.image;
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
              if ( layoutConst == null ) {
                layoutConst = "P" ;
              }
    jj_consume_token(62);
                MathObject part0= (UserFunction) parts.get(0);
                MathObject part1= (UserFunction) parts.get(1);
                MathObject part2= (UserFunction) parts.get(2);
                MathObject part3= (UserFunction) parts.get(3);

                MathObject mo= new DiscreteSequence(part0, part1, part2, part3, layoutConst, broker, viewFactory);
                DiscreteSequence.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newDiscreteSequenceUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newDiscreteSequenceObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newStraightObject(List regList) throws ParseException, Exception {
    List parts = new ArrayList();
    UserFunction moPath;
    jj_consume_token(STRAIGHT);
    jj_consume_token(60);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    moPath = vectorFunctionReference(regList);
                   parts.add(moPath);
    jj_consume_token(62);
                MathObject point= (UserFunction) parts.get(0);
                MathObject vector= (UserFunction) parts.get(1);
                MathObject mo= new Straight(point, vector, broker, viewFactory);
                Straight.register(mo, parts, regList, broker);
                regList.add(mo);
                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newStraightUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newStraightObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newCircleObject(List regList) throws ParseException, Exception {
        TermNode rTerm;
        UserFunction rFunction;
    Set refObjPaths= new HashSet();
    List parts = new ArrayList();
    UserFunction moPath;
    MathObject mo;
    jj_consume_token(CIRCLE);
    jj_consume_token(60);
    moPath = pointReference(regList);
                   parts.add(moPath);
    jj_consume_token(61);
    rFunction = scalarFunctionReference(regList);
                                parts.add(1, rFunction);
    jj_consume_token(62);
                                MathObject center= (UserFunction) parts.get(0);
                                MathObject radius= (UserFunction) parts.get(1);
                                mo= new Circle(center, radius, broker, viewFactory);
                                Circle.register(mo, parts, regList, broker);
                                regList.add(mo);
                                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newCircleUserFunction(List regList) throws ParseException, Exception {
        List localRegList = new ArrayList();
        MathObject mo;
    mo = newCircleObject(localRegList);
                        {if (true) return objectToUserFunction(mo, localRegList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newPointObject(List regList) throws ParseException, Exception {
        UserFunction xFunction, yFunction;
        List parts = new ArrayList();
    jj_consume_token(POINT);
    jj_consume_token(60);
    xFunction = scalarFunctionReference(regList);
                parts.add(xFunction);
    jj_consume_token(61);
    yFunction = scalarFunctionReference(regList);
                parts.add(yFunction);
    jj_consume_token(62);
                        MathObject part0 = (UserFunction) parts.get(0);
                                MathObject part1 = (UserFunction) parts.get(1);
                        MathObject mo = new AffPoint(part0, part1, broker, viewFactory);
                                AffPoint.register(mo, parts, regList, broker);
                                regList.add(mo);
                                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newPointUserFunction(List regList) throws ParseException, Exception {
        MathObject mo;
    mo = newPointObject(regList);
                        {if (true) return objectToUserFunction(mo, regList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject newMarkerObject(List regList) throws ParseException, Exception {
        UserFunction xFunction, yFunction;
        List parts = new ArrayList();
    jj_consume_token(MARKER);
    jj_consume_token(60);
    xFunction = scalarFunctionReference(regList);
                parts.add(xFunction);
    jj_consume_token(61);
    yFunction = scalarFunctionReference(regList);
                parts.add(yFunction);
    jj_consume_token(62);
                        MathObject part0 = (UserFunction) parts.get(0);
                                MathObject part1 = (UserFunction) parts.get(1);
                        MathObject mo = new Marker(part0, part1, broker, viewFactory);
                                Marker.register(mo, parts, regList, broker);
                                regList.add(mo);
                                {if (true) return mo;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction newMarkerUserFunction(List regList) throws ParseException, Exception {
        MathObject mo;
    mo = newMarkerObject(regList);
                        {if (true) return objectToUserFunction(mo, regList, broker);}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction pointReference(List regList) throws ParseException, Exception {
        UserFunction rFunction;
        TermNode rTerm;
        Set refObjPaths= new HashSet();
        List localRegList = new ArrayList();
        UserFunction moPath;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POINT:
      moPath = newPointUserFunction(regList);
      break;
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      rTerm = sum(new ArrayList(), new ArrayList(), refObjPaths, localRegList);
                                if ( !AffPoint.class.isAssignableFrom(rTerm.getResultType()) ) {
                                        {if (true) throw new Exception("Falscher Typ: erwartet:"
                                                            + AffPoint.class.toString()
                                                            + " vorhanden: " + rTerm.getResultType().toString() );}
                                }
                                rFunction= new UserFunction(rTerm, new ScalarVariable[0], broker, viewFactory);
                                UserFunction.register(rFunction, new ArrayList(refObjPaths), localRegList, broker);
                                regList.add(rFunction);
                                moPath = rFunction;
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                        {if (true) return moPath;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction generalFunctionReference(List regList) throws ParseException, Exception {
        UserFunction rFunction;
        Set refObjPaths= new HashSet();
        List localRegList = new ArrayList();
        TermNode rTerm;
    rTerm = sum(new ArrayList(), new ArrayList(), refObjPaths, localRegList);
                                rFunction= new UserFunction(rTerm, new ScalarVariable[0], broker, viewFactory);
                                UserFunction.register(rFunction, new ArrayList(refObjPaths), localRegList, broker);
                        regList.add(rFunction);
                        {if (true) return rFunction;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction scalarFunctionReference(List regList) throws ParseException, Exception {
        UserFunction rFunction;
    rFunction = generalFunctionReference(regList);
                Class rClass = rFunction.getResultType();
                if ( rClass != ScalarType.class ) {
                        {if (true) throw new Exception("Falscher Typ: erwartet:"
                                                            + ScalarType.class.toString()
                                                            + " vorhanden: " + rClass.toString() );}
                }
                {if (true) return rFunction;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction vectorFunctionReference(List regList) throws ParseException, Exception {
        UserFunction rFunction;
    rFunction = generalFunctionReference(regList);
                Class rClass = rFunction.getResultType();
                if ( rClass != VectorType.class ) {
                        {if (true) throw new Exception("Falscher Typ: erwartet:"
                                                            + VectorType.class.toString()
                                                            + " vorhanden: " + rClass.toString() );}
                }
                {if (true) return rFunction;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction dualVectorFunctionReference(List regList) throws ParseException, Exception {
        UserFunction rFunction;
    rFunction = generalFunctionReference(regList);
                Class rClass = rFunction.getResultType();
                if ( rClass != DualVectorType.class ) {
                        {if (true) throw new Exception("Falscher Typ: erwartet:"
                                                            + DualVectorType.class.toString()
                                                            + " vorhanden: " + rClass.toString() );}
                }
                {if (true) return rFunction;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction matrixFunctionReference(List regList) throws ParseException, Exception {
        UserFunction rFunction;
    rFunction = generalFunctionReference(regList);
                Class rClass = rFunction.getResultType();
                if ( rClass != MatrixType.class ) {
                        {if (true) throw new Exception("Falscher Typ: erwartet:"
                                                            + MatrixType.class.toString()
                                                            + " vorhanden: " + rClass.toString() );}
                }
                {if (true) return rFunction;}
    throw new Error("Missing return statement in function");
  }

  static final public void areaElement(List parts, List regList) throws ParseException, Exception {
        String funcname;
        MathObject mo;
        UserFunction moPath;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      moPath = generalFunctionReference(regList);
      break;
    case CURVE:
      moPath = newCurveUserFunction(regList);
      break;
    case POINT:
      moPath = newPointUserFunction(regList);
      break;
    case STRETCH:
      moPath = newStretchUserFunction(regList);
      break;
    case BEZIER:
      moPath = newBezierUserFunction(regList);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                  regList.add(moPath);
                  parts.add(moPath);
  }

/**
 * Partielle Ableitung
 */
  static final public UserFunction pDeriveBody(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
        List deriveVars= new ArrayList();
        TermNode term, deriveVarTerm;
    term = sum(vars, varNames, refObjPaths, regList);
    jj_consume_token(61);
    deriveVarTerm = sum(vars, varNames, refObjPaths, regList);
                //System.out.println("ßßßß" + deriveVarTerm.getClass().toString() );
                if (!(deriveVarTerm instanceof ScalarVariable)) {
                        {if (true) throw new ParseException(token.beginColumn, "Name einer Variablen erwartet");}
                }
                deriveVars.add(deriveVarTerm);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 61:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_12;
      }
      jj_consume_token(61);
      deriveVarTerm = sum(vars, varNames, refObjPaths, regList);
                        if (!(deriveVarTerm instanceof ScalarVariable)) {
                                {if (true) throw new ParseException(token.beginColumn, "Name einer Variablen erwartet");}
                        }
                        deriveVars.add(deriveVarTerm);
    }
                UserFunction f = new UserPderiveFunction(term,
                        (ScalarVariable[]) (vars.toArray(new ScalarVariable[0])),
                        (ScalarVariable[]) (deriveVars.toArray(new ScalarVariable[0])),
                        broker, viewFactory);
                regList.add(f);
                {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject functionDefinitionBody(List vars, List varNames, List regList) throws ParseException, Exception {
        TermNode term;
        Function f;
        Set refObjPaths= new HashSet();
    term = sum(vars, varNames, refObjPaths, regList);
                f= new UserFunction(term, (Variable[]) vars.toArray(new Variable[0]), broker, viewFactory);
                UserFunction.register(f, new ArrayList(refObjPaths), regList, broker);
                regList.add(f);
                {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parse die Definition eines Objekts (z.B. Punkt, Strecke, Flaeche), dessen Typ
 * durch einen entsprechenden Bezeichner (keyword) bestimmt ist
 * (z.B. punkt(...), strecke(....), ...), erzeugt das Objekt und
 * gibt es zur¸ck. F¸gt an regList s‰mtliche Objekte an,
 * die w‰hrend des Parse-Vorgangs neu erzeugt wurden.
 * @param regList Hier werden s‰mtliche Objekte eingetragen, die waehrend
 * des Parse-Vorgangs neu erzeugt wurden,
 * @return Das neu erzeugte Objekt
 * @throws Exception
 */
  static final public MathObject keywordDefinitionBody(List regList) throws ParseException, Exception {
        MathObject mo= null, part0, part1, part2, part3;
        TermNode term;
        List vars= new ArrayList();
        List varNames= new ArrayList();
        Set refObjPaths= new HashSet();
        List parts= new ArrayList();
        UserFunction moPath;

        if (vars.size() > 0) {
                throw new ParseException(token.beginColumn, "ScalarVariable bei Objekt von diesem Typ nicht erlaubt");
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PFEIL:
      mo = newArrowUserFunction(regList);
                {if (true) return mo;}
      break;
    case CIRCLE:
      mo = newCircleUserFunction(regList);
                {if (true) return mo;}
      break;
    case CURVE:
      mo = newCurveUserFunction(regList);
                {if (true) return mo;}
      break;
    case POINT:
      mo = newPointUserFunction(regList);
                {if (true) return mo;}
      break;
    case MARKER:
      mo = newMarkerUserFunction(regList);
                {if (true) return mo;}
      break;
    case KARTE:
      mo = newMapUserFunction(regList);
                {if (true) return mo;}
      break;
    case BAR:
      mo = newBarUserFunction(regList);
                {if (true) return mo;}
      break;
    case DISCRETE:
      mo = newDiscreteUserFunction(regList);
                {if (true) return mo;}
      break;
    case DISCRETESEQ:
      mo = newDiscreteSequenceUserFunction(regList);
                {if (true) return mo;}
      break;
    case ANGLE:
      mo = newAngleUserFunction(regList);
                {if (true) return mo;}
      break;
    case STRETCH:
      mo = newStretchUserFunction(regList);
                {if (true) return mo;}
      break;
    case BEZIER:
      mo = newBezierUserFunction(regList);
                {if (true) return mo;}
      break;
    case STRAIGHT:
      mo = newStraightUserFunction(regList);
                {if (true) return mo;}
      break;
    case COMPOUNDCURVE:
    case AREA:
      mo = newAreaUserFunction(regList);
                {if (true) return mo;}
      break;
    case FIELD:
      mo = newFieldUserFunction(regList);
                {if (true) return mo;}
      break;
    case TEXTELEMENT:
      mo = newTextUserFunction(regList);
                {if (true) return mo;}
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public MathObject sequenceDefinitionBody(Object defHead, List vars, List regList) throws ParseException, Exception {
        int startIndex = 0;
        List basisElements = new LinkedList();
        Set parts= new HashSet();
        TermNode recursionTerm;
        String localVarName;
        ScalarVariable localVar;
        List localVars = new LinkedList();
        List localVarNames = new LinkedList();
        Set localParts= new HashSet();
        List localRegList = new ArrayList();
        Sequence seq;
        UserFunction seqFunction, f;
        TermNodeDoubleResult dummyResult = new TermNodeDoubleResult((DoubleResult)ScalarType.getDummyObject());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      jj_consume_token(LT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCALAR:
        jj_consume_token(SCALAR);
                                dummyResult = new TermNodeDoubleResult((DoubleResult)ScalarType.getDummyObject());
        break;
      case MATRIX:
        jj_consume_token(MATRIX);
                                dummyResult = new TermNodeDoubleResult((DoubleResult)MatrixType.getDummyObject());
        break;
      case VECTOR:
        jj_consume_token(VECTOR);
                                dummyResult = new TermNodeDoubleResult((DoubleResult)VectorType.getDummyObject());
        break;
      case DUALVECTOR:
        jj_consume_token(DUALVECTOR);
                                dummyResult = new TermNodeDoubleResult((DoubleResult)DualVectorType.getDummyObject());
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(GT);
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEQUENCE:
      jj_consume_token(SEQUENCE);
                 startIndex = 1;
      break;
    case SEQUENCE0:
      jj_consume_token(SEQUENCE0);
                  startIndex = 0;
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(60);
    jj_consume_token(Bezeichner);
                        localVarName= token.image;
                        localVar= new ScalarVariable(localVarName);
            localVar.setValue(new ScalarDoubleResult(1));
    jj_consume_token(61);
    basisElements = basisList(localVars, localVarNames, parts, regList);
    jj_consume_token(61);
                localVars.add(localVar);
                        localVarNames.add(localVarName);

                        if(defHead instanceof String && vars.isEmpty()) {
                                if( broker.getMathObject(defHead) != null  ){
                                        seqFunction = (UserFunction)broker.getMathObject(defHead);
                                        TermNode seqTerm = seqFunction.getFunction();
                                        seq = (Sequence)(((PathReference)seqTerm).getRootObject());
                                        seq.redefine(startIndex, localVar,
                                     basisElements, dummyResult, broker );
                                }
                                else {
                                        seq = new Sequence((String)defHead, startIndex, localVar,
                                     basisElements, dummyResult, broker, viewFactory );
                    TermNode seqTerm = new PathReference(seq, new LinkedList(),  broker);
                                seqFunction= new UserFunction(seqTerm, new ScalarVariable[0], broker, viewFactory);
                                        broker.publishObject( seqFunction, (String)defHead );
                                }
                        // in regList einfuegen, dann wird es bei Auftreten eines Fehlers
                        // wieder gelˆscht
                        regList.add(seqFunction);

                }
                else{
            {if (true) throw new ParseException("Der Name einer Folge muss ein Bezeichner sein.");}
        }
    recursionTerm = sum(localVars, localVarNames, localParts, localRegList);
    jj_consume_token(62);
         Set refObjPaths= new HashSet();
        f = new UserFunction(recursionTerm, (Variable[]) vars.toArray(new Variable[0]), broker, viewFactory);
                                UserFunction.register(f, new ArrayList(localParts), localRegList, broker);
                                regList.add(f);
                parts.add(f);
        seq.setRecursion( f );
        regList.remove(seqFunction);
        parts.remove( seq);
        seq.register(seq, new ArrayList(parts), regList, broker);
                regList.add(seq);
                List temp = new ArrayList();
                temp.add(seq);
                try {
                                  UserFunction.register(seqFunction, new ArrayList(temp), regList, broker);
                }
                catch( BrokerException e ) {
                                ExceptionManager.doError("Fehler beim Erzeugen der Funktion "+seqFunction,e);
                }
        regList.add(seqFunction);
        {if (true) return seqFunction;}
    throw new Error("Missing return statement in function");
  }

  static final public MathObject listDefinitionBody(List regList) throws ParseException, Exception {
        Class listElementClass;
        Object dummy= null;
        UserFunction moPath;
        List l= new LinkedList();
        List parts= new LinkedList();
        List varNames= new ArrayList();
        List vars= new ArrayList();
        int startIndex = 1;
    jj_consume_token(LT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FUNCTION:
      jj_consume_token(FUNCTION);
      variableDeclaration(vars, varNames);
                        listElementClass= Class.forName("math4u2.mathematics.functions.Function");
                        dummy= new FunctionDummy(varNames.size());
      break;
    case POINT:
      jj_consume_token(POINT);
                        listElementClass= Class.forName("math4u2.mathematics.affine.AffPoint");
      break;
    case STRETCH:
      jj_consume_token(STRETCH);
                        listElementClass= Class.forName("math4u2.mathematics.affine.Stretch");
      break;
    case PFEIL:
      jj_consume_token(PFEIL);
                        listElementClass= Class.forName("math4u2.mathematics.affine.Arrow");
      break;
    case CIRCLE:
      jj_consume_token(CIRCLE);
                        listElementClass= Class.forName("math4u2.mathematics.affine.Circle");
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(GT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIST:
      jj_consume_token(LIST);
                 startIndex = 1;
      break;
    case LIST0:
      jj_consume_token(LIST0);
                  startIndex = 0;
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_4(2)) {
      jj_consume_token(60);
      jj_consume_token(67);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
      case SUM:
      case PRODUCT:
      case DERIVE:
      case PDERIVE:
      case POINT:
      case MATRIX:
      case DIAGMATRIX:
      case EMATRIX:
      case VECTOR:
      case DUALVECTOR:
      case Zahl:
      case Bezeichner:
      case 60:
      case 65:
        moPath = listItemDefinition(listElementClass, varNames, regList);
                        parts.add(moPath);
                        l.add(moPath);
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 61:
            ;
            break;
          default:
            jj_la1[52] = jj_gen;
            break label_13;
          }
          jj_consume_token(61);
          moPath = listItemDefinition(listElementClass, varNames, regList);
                                parts.add(moPath);
                                l.add(moPath);
        }
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      jj_consume_token(68);
      jj_consume_token(62);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 60:
        jj_consume_token(60);
        l = indexedListElements(listElementClass,startIndex,  vars, varNames, parts, regList);
        jj_consume_token(62);
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                MathList ml= new MathList(startIndex, listElementClass, l, broker, viewFactory);
                ml.register(ml, parts, regList, broker);
                regList.add(ml);
                TermNode rTerm = new PathReference(ml, new LinkedList(),  broker);
                UserFunction rFunction= new UserFunction(rTerm, new ScalarVariable[0], broker, viewFactory);
                List temp = new ArrayList();
                temp.add(ml);
                try {
                                  UserFunction.register(rFunction, new ArrayList(temp), regList, broker);
                }
                catch( BrokerException e ) {
                                ExceptionManager.doError("Fehler beim Erzeugen der Funktion "+rFunction,e);
                }
        regList.add(rFunction);
        {if (true) return rFunction;}
    throw new Error("Missing return statement in function");
  }

  static final public List indexedListElements(Class ListElementClass, int startIndex, List vars, List varNames, List parts,  List regList) throws ParseException, Exception {
   String localVarName;
   List localVars, localVarNames, result;
   Variable localVar;
   Variable [] varArray;
   TermNode dimensionTerm, xTerm, yTerm, term;
   int dimension;
   UserFunction xFunction, yFunction;
   MathObject mo;
   Function f;
    jj_consume_token(Bezeichner);
                localVarName= token.image;
                for (int i= 0; i < varNames.size(); i++) {
                        if (localVarName.compareTo((String) (varNames.get(i))) == 0)
                                {if (true) throw new ParseException(
                                        token.beginColumn,
                                        "Variablenname \"" + localVarName + "\" bereits verwendet");}
                }
                //List vars = new ArrayList();
                //localVar = new ScalarVariable(localVarName);
                //vars.add(localVar);
                Set refObjPaths= new HashSet();
    jj_consume_token(61);
    dimensionTerm = sum(vars, varNames, refObjPaths, regList);
                // pruefen, ob dimensionTerm Variable enthaelt, wenn ja: Exception
                if ( dimensionTerm.hasVar() )
                   {if (true) throw new ParseException("Term fuer Dimension eines Vektors oder einer Matrix enthaelt eine Variable");}

                // Wert von dimensionTerm zu doubleDimension berechnen
                double doubleDimension = dimensionTerm.evalScalar();

                // pruefen, ob doubleDimension natuerliche Zahl ( ganz, >= 1 )
                if ( doubleDimension <= 0 )
                   {if (true) throw new ParseException("Dimension eines Vektors ist <= 0");}
                if ( doubleDimension != (int)doubleDimension )
                   {if (true) throw new ParseException("Dimension eines Vektors ist keine natuerliche Zahl");}

                dimension = (int)doubleDimension;



                localVar= new ScalarVariable(localVarName);
                localVar.setValue(new ScalarDoubleResult(1));
                localVars = new ArrayList(vars);
                localVars.add(localVar);
                localVarNames= new ArrayList(varNames);
                localVarNames.add(localVarName);
    jj_consume_token(61);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POINT:
      jj_consume_token(POINT);
                Set xRefObjPaths= new HashSet();
      jj_consume_token(60);
      xTerm = sum(localVars, localVarNames, xRefObjPaths, regList);
                Set yRefObjPaths= new HashSet();
      jj_consume_token(61);
      yTerm = sum(localVars, localVarNames, yRefObjPaths, regList);
      jj_consume_token(62);
                result = new ArrayList(); // leere Ergebnisliste

              varArray = new Variable[localVars.size()];
              localVars.toArray( varArray );

              for( int index = startIndex; index < dimension + startIndex; index ++ ) {
                // term  zu clonedTerm klonen
                TermNode clonedXTerm = xTerm.getClone( varArray , varArray  ).substitute(new Variable[] {localVar}, new TermNode[] {new TermNodeNum(index)});
                TermNode clonedYTerm = yTerm.getClone( varArray , varArray  ).substitute(new Variable[] {localVar}, new TermNode[] {new TermNodeNum(index)});

                // in clonedTerm lokale Variable durch Wert von Index ersetzen
                // clonedTerm hinten an result anhaengen

                xFunction= new UserFunction(clonedXTerm, (ScalarVariable[]) vars.toArray(new ScalarVariable[0]), broker, viewFactory);
                UserFunction.register(xFunction, new ArrayList(xRefObjPaths), regList, broker);
                regList.add(xFunction);

                 yFunction= new UserFunction(clonedYTerm, (ScalarVariable[]) vars.toArray(new ScalarVariable[0]), broker, viewFactory);
                UserFunction.register(yFunction, new ArrayList(yRefObjPaths), regList, broker);
                regList.add(yFunction);


                List pointParts = new LinkedList();
                pointParts.add(xFunction);
                pointParts.add(yFunction);

                mo= new AffPoint(xFunction,yFunction, broker, viewFactory);
                AffPoint.register(mo, pointParts, regList, broker);
                regList.add(mo);

                //parts.add(new MathObjectPath(mo));

                //result.add( mo);

                UserFunction moPath = objectToUserFunction( mo, regList, broker );
                parts.add(moPath);
                result.add(moPath);

              }
              {if (true) return result;}
      break;
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      term = sum(localVars, localVarNames, refObjPaths, regList);
              result = new ArrayList(); // leere Ergebnisliste

              varArray = new Variable[localVars.size()];
              localVars.toArray( varArray );

              for( int index = startIndex; index < dimension + startIndex; index ++ ) {
                // term  zu clonedTerm klonen
                TermNode clonedTerm = term.getClone( varArray , varArray  );
                clonedTerm = clonedTerm.substitute(new Variable[] {localVar}, new TermNode[] {new TermNodeNum(index)});
                // in clonenTerm lokale Variable durch Wert von Index ersetzen
                // clonedTerm hinten an result anhaengen


                                f = new UserFunction(clonedTerm, (Variable[]) vars.toArray(new Variable[0]), broker, viewFactory);
                                UserFunction.register(f, new ArrayList(refObjPaths), regList, broker);
                                regList.add(f);
                parts.add(f);
                result.add( f );

              }

              {if (true) return result;}
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public List matrixRow(List vars, List varNames,Set refObjPaths, List regList) throws ParseException, Exception {
  LinkedList rowElements = new LinkedList();
  TermNode element;
    jj_consume_token(67);
    element = sum(vars, varNames, refObjPaths, regList);
              rowElements.add(element);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 61:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_14;
      }
      jj_consume_token(61);
      element = sum(vars, varNames, refObjPaths, regList);
                  rowElements.add(element);
    }
    jj_consume_token(68);
       {if (true) return rowElements;}
    throw new Error("Missing return statement in function");
  }

  static final public List basisList(List vars, List varNames,Set refObjPaths, List regList) throws ParseException, Exception {
  LinkedList rowElements = new LinkedList();
  TermNode element;
    jj_consume_token(67);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      element = sum(vars, varNames, refObjPaths, regList);
                 rowElements.add(element);
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 61:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_15;
      }
      jj_consume_token(61);
      element = sum(vars, varNames, refObjPaths, regList);
                  rowElements.add(element);
    }
    jj_consume_token(68);
       {if (true) return rowElements;}
    throw new Error("Missing return statement in function");
  }

  static final public TermNode matrixNodeDefinition(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
  List rowElements;
  List rowList = new LinkedList();
  int rowDim, colDim;
  MathObject mo;
  TermNode [][] elementArray;
  TermNode [] elementVector;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MATRIX:
      jj_consume_token(MATRIX);
      jj_consume_token(60);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 67:
        jj_consume_token(67);
        rowElements = matrixRow(vars, varNames, refObjPaths, regList);
                 colDim = rowElements.size();
                 rowList.add(rowElements);
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 61:
            ;
            break;
          default:
            jj_la1[59] = jj_gen;
            break label_16;
          }
          jj_consume_token(61);
          rowElements = matrixRow(vars, varNames, refObjPaths, regList);
                  if ( rowElements.size() != colDim )
                          {/*Ausnahme erzeugen*/}
                  else
                    rowList.add(rowElements);
        }
        jj_consume_token(68);
        break;
      case Bezeichner:
        rowList = indexedMatrixElements(vars, varNames, refObjPaths, regList);
                 colDim = ((List)(rowList.get(0))).size();
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(62);
       rowDim = rowList.size();
       elementArray = new TermNode [rowDim][colDim];
       for ( int r=0; r<rowDim; r++ ) {
         for ( int c=0; c<colDim; c++ ) {
           elementArray[r][c] = (TermNode)(((List)rowList.get(r)).get(c));
         }
       }
       {if (true) return new TermNodeMatrix(elementArray);}
      break;
    case DIAGMATRIX:
      jj_consume_token(DIAGMATRIX);
      jj_consume_token(60);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 67:
        rowElements = matrixRow(vars, varNames, refObjPaths, regList);
        break;
      case Bezeichner:
        rowElements = indexedVectorElements(vars, varNames, refObjPaths, regList);
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(62);
       rowDim = rowElements.size();
       colDim = rowDim;
       elementVector = new TermNode [rowDim];
       for ( int r=0; r<rowDim; r++ ) {
             elementVector[r] = (TermNode)(rowElements.get(r));
       }
       {if (true) return new TermNodeDiagMatrix(elementVector);}
      break;
    case EMATRIX:
      jj_consume_token(EMATRIX);
      jj_consume_token(60);
      jj_consume_token(Zahl);
              try {
                 rowDim = Integer.parseInt(token.image);
              }
              catch (NumberFormatException e) {
                   {if (true) throw new ParseException(token.beginColumn, e.toString());}
              }
      jj_consume_token(62);
       {if (true) return new TermNodeUnitMatrix(rowDim);}
      break;
    case VECTOR:
      jj_consume_token(VECTOR);
      jj_consume_token(60);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 67:
        rowElements = matrixRow(vars, varNames, refObjPaths, regList);
        break;
      case Bezeichner:
        rowElements = indexedVectorElements(vars, varNames, refObjPaths, regList);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(62);
       rowDim = rowElements.size();
       colDim = 1;
       elementVector = new TermNode [rowDim];
       for ( int r=0; r<rowDim; r++ ) {
           elementVector[r] = (TermNode)(rowElements.get(r));
       }
       {if (true) return new TermNodeVector(elementVector);}
      break;
    case DUALVECTOR:
      jj_consume_token(DUALVECTOR);
      jj_consume_token(60);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 67:
        rowElements = matrixRow(vars, varNames, refObjPaths, regList);
        break;
      case Bezeichner:
        rowElements = indexedVectorElements(vars, varNames, refObjPaths, regList);
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(62);
       colDim = rowElements.size();
       rowDim = 1;
       elementVector = new TermNode[colDim];
       for ( int c=0; c<colDim; c++ ) {
           elementVector[c] = (TermNode)(rowElements.get(c));
       }
       {if (true) return new TermNodeDualVector(elementVector);}
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public List indexedVectorElements(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
   String localVarName;
   List localVars, localVarNames;
   Variable localVar;
   TermNode dimensionTerm, term;
   int dimension;
    jj_consume_token(Bezeichner);
                localVarName= token.image;
                for (int i= 0; i < varNames.size(); i++) {
                        if (localVarName.compareTo((String) (varNames.get(i))) == 0)
                                {if (true) throw new ParseException(
                                        token.beginColumn,
                                        "Variablenname \"" + localVarName + "\" bereits verwendet");}
                }
    jj_consume_token(61);
    dimensionTerm = sum(vars, varNames, refObjPaths, regList);
                // pruefen, ob dimensionTerm Variable enthaelt, wenn ja: Exception
                if ( dimensionTerm.hasVar() )
                   {if (true) throw new ParseException("Term fuer Dimension eines Vektors oder einer Matrix enthaelt eine Variable");}

                // Wert von dimensionTerm zu doubleDimension berechnen
                double doubleDimension = dimensionTerm.evalScalar();

                // pruefen, ob doubleDimension natuerliche Zahl ( ganz, >= 1 )
                if ( doubleDimension <= 0 )
                   {if (true) throw new ParseException("Dimension eines Vektors ist <= 0");}
                if ( doubleDimension != (int)doubleDimension )
                   {if (true) throw new ParseException("Dimension eines Vektors ist keine natuerliche Zahl");}

                dimension = (int)doubleDimension;
                // in den beiden Listen lokale ScalarVariable anh‰ngen
                localVar= new ScalarVariable(localVarName);
                localVar.setValue(new ScalarDoubleResult(1));
                localVars = new ArrayList(vars);
                localVars.add(localVar);
                localVarNames= new ArrayList(varNames);
                localVarNames.add(localVarName);
    jj_consume_token(61);
    term = sum(localVars, localVarNames, refObjPaths, regList);
              List result = new ArrayList(); // leere Ergebnisliste

              Variable [] varArray = new Variable[localVars.size()];
              localVars.toArray( varArray );

              for( int index = 1; index <= dimension; index ++ ) {
                // term  zu clonedTerm klonen
                TermNode clonedTerm = term.getClone( varArray , varArray  );
                // in clonenTerm lokale Variable durch Wert von Index ersetzen
                // clonedTerm hinten an result anhaengen

                result.add( clonedTerm.substitute(new Variable[] {localVar}, new TermNode[] {new TermNodeNum(index)}));

              }

              {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public List indexedMatrixElements(List vars, List varNames, Set refObjPaths, List regList) throws ParseException, Exception {
   String localVarName1, localVarName2;
   List localVars, localVarNames;
   Variable localVar1, localVar2;
   TermNode dimensionTerm1, dimensionTerm2, term;
   int dimension1, dimension2;
    jj_consume_token(Bezeichner);
                localVarName1= token.image;
                for (int i= 0; i < varNames.size(); i++) {
                        if (localVarName1.compareTo((String) (varNames.get(i))) == 0)
                                {if (true) throw new ParseException(
                                        token.beginColumn,
                                        "Variablenname \"" + localVarName1 + "\" bereits verwendet");}
                }
    jj_consume_token(61);
    dimensionTerm1 = sum(vars, varNames, refObjPaths, regList);
                // pruefen, ob dimensionTerm1 Variable enthaelt, wenn ja: Exception
                if ( dimensionTerm1.hasVar() )
                   {if (true) throw new ParseException("Term fuer Dimension einer Matrix enthaelt eine Variable");}

                // Wert von dimensionTerm1 zu doubleDimension berechnen
                double doubleDimension1 = dimensionTerm1.evalScalar();

                // pruefen, ob doubleDimension1 natuerliche Zahl ( ganz, >= 1 )
                if ( doubleDimension1 <= 0 )
                   {if (true) throw new ParseException("Dimension einer Matrix ist <= 0");}
                if ( doubleDimension1 != (int)doubleDimension1 )
                   {if (true) throw new ParseException("Dimension einer Matrix ist keine natuerliche Zahl");}

                dimension1 = (int)doubleDimension1;
                // in den beiden Listen lokale ScalarVariable anh‰ngen
                localVar1= new ScalarVariable(localVarName1);
                localVar1.setValue(new ScalarDoubleResult(1));
                localVars= new ArrayList(vars);
                localVars.add(localVar1);
                localVarNames= new ArrayList(varNames);
                localVarNames.add(localVarName1);
    jj_consume_token(61);
    jj_consume_token(Bezeichner);
                localVarName2= token.image;
                for (int i= 0; i < localVarNames.size(); i++) {
                        if (localVarName2.compareTo((String) (localVarNames.get(i))) == 0)
                                {if (true) throw new ParseException(
                                        token.beginColumn,
                                        "Variablenname \"" + localVarName2 + "\" bereits verwendet");}
                }
    jj_consume_token(61);
    dimensionTerm2 = sum(vars, varNames, refObjPaths, regList);
                // pruefen, ob dimensionTerm2 Variable enthaelt, wenn ja: Exception
                if ( dimensionTerm2.hasVar() )
                   {if (true) throw new ParseException("Term fuer Dimension einer Matrix enthaelt eine Variable");}

                // Wert von dimensionTerm2 zu doubleDimension berechnen
                double doubleDimension2 = dimensionTerm2.evalScalar();

                // pruefen, ob doubleDimension2 natuerliche Zahl ( ganz, >= 1 )
                if ( doubleDimension2 <= 0 )
                   {if (true) throw new ParseException("Dimension einer Matrix ist <= 0");}
                if ( doubleDimension2 != (int)doubleDimension2 )
                   {if (true) throw new ParseException("Dimension einer Matrix ist keine natuerliche Zahl");}

                dimension2 = (int)doubleDimension2;
                // in den beiden Listen lokale ScalarVariable anh‰ngen
                localVar2= new ScalarVariable(localVarName2);
                localVar2.setValue(new ScalarDoubleResult(1));
                localVars.add(localVar2);
                localVarNames.add(localVarName2);
    jj_consume_token(61);
    term = sum(localVars, localVarNames, refObjPaths, regList);
              List result = new ArrayList(); // leere Ergebnisliste

              Variable [] varArray = new Variable[localVars.size()];
              localVars.toArray( varArray );

              for( int row = 1; row <= dimension1; row ++ ) {
                List rowList = new LinkedList();
                TermNode clonedRowTerm = term.getClone( varArray , varArray  ).substitute(new Variable[] {localVar1}, new TermNode[] {new TermNodeNum(row)});

                for ( int col = 1; col <= dimension2; col++ ) {
                    TermNode clonedTerm = clonedRowTerm.getClone( varArray , varArray  );
                    // in clonenTerm lokale Variable durch Wert von Index ersetzen
                    // clonedTerm hinten an result anhaengen
                    TermNode sub = clonedTerm.substitute(new Variable[] {localVar2}, new TermNode[] {new TermNodeNum(col)});
                    rowList.add(sub);
                 }
                 result.add(rowList);
              }
              {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public UserFunction listItemDefinition(Class itemClass, List varNames, List regList) throws ParseException, Exception {
        UserFunction moPath;
        Set refObjPaths = new HashSet();
        TermNode rTerm;
        List vars= new ArrayList();
                        for (int i= 0; i < varNames.size(); i++)
                                vars.add(new ScalarVariable((String) (varNames.get(i))));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POINT:
      moPath = newPointUserFunction(regList);
      break;
    case MINUS:
    case SUM:
    case PRODUCT:
    case DERIVE:
    case PDERIVE:
    case MATRIX:
    case DIAGMATRIX:
    case EMATRIX:
    case VECTOR:
    case DUALVECTOR:
    case Zahl:
    case Bezeichner:
    case 60:
    case 65:
      rTerm = sum(vars, varNames, refObjPaths, regList);
                        UserFunction rFunction= new UserFunction(rTerm, (Variable[]) vars.toArray(new Variable[0]), broker, viewFactory);
                        UserFunction.register(rFunction, new ArrayList(refObjPaths), regList, broker);
                        regList.add(rFunction);
                        moPath = rFunction;
      break;
    default:
      jj_la1[65] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        regList.add(moPath);
        {if (true) return moPath;}
    throw new Error("Missing return statement in function");
  }

  static final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static final private boolean jj_3_2() {
    if (jj_scan_token(EXP)) return true;
    return false;
  }

  static final private boolean jj_3R_20() {
    if (jj_scan_token(POINT)) return true;
    return false;
  }

  static final private boolean jj_3R_30() {
    if (jj_scan_token(66)) return true;
    return false;
  }

  static final private boolean jj_3R_19() {
    if (jj_scan_token(FUNCTION)) return true;
    return false;
  }

  static final private boolean jj_3R_28() {
    if (jj_scan_token(60)) return true;
    return false;
  }

  static final private boolean jj_3_1() {
    if (jj_3R_17()) return true;
    return false;
  }

  static final private boolean jj_3_3() {
    if (jj_3R_18()) return true;
    return false;
  }

  static final private boolean jj_3R_17() {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) return true;
    }
    }
    }
    }
    return false;
  }

  static final private boolean jj_3_4() {
    if (jj_scan_token(60)) return true;
    if (jj_scan_token(67)) return true;
    return false;
  }

  static final private boolean jj_3R_18() {
    if (jj_scan_token(Bezeichner)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_24()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static final private boolean jj_3R_29() {
    if (jj_scan_token(63)) return true;
    return false;
  }

  static final private boolean jj_3R_27() {
    if (jj_3R_30()) return true;
    return false;
  }

  static final private boolean jj_3R_23() {
    if (jj_scan_token(CIRCLE)) return true;
    return false;
  }

  static final private boolean jj_3R_26() {
    if (jj_3R_29()) return true;
    return false;
  }

  static final private boolean jj_3R_22() {
    if (jj_scan_token(PFEIL)) return true;
    return false;
  }

  static final private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) return true;
    }
    }
    return false;
  }

  static final private boolean jj_3R_25() {
    if (jj_3R_28()) return true;
    return false;
  }

  static final private boolean jj_3R_21() {
    if (jj_scan_token(STRETCH)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  static public parserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static public boolean lookingAhead = false;
  static private boolean jj_semLA;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[66];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x2000,0xfff7a040,0x0,0x2000,0x0,0x0,0x2000,0x60,0x60,0x78040,0x2280,0x2280,0x800,0x0,0x0,0x78000,0x18000,0x80000,0x0,0x0,0x78040,0x0,0x80000,0x0,0x78040,0x0,0x18000,0x60000,0x0,0x78040,0x0,0x20400000,0x0,0x0,0x0,0x0,0x0,0x0,0x20200000,0x0,0x80578040,0x0,0x0,0x478040,0x80578040,0x0,0xfff00000,0x0,0x2000,0x0,0xc0400000,0x0,0x0,0x478040,0x0,0x478040,0x0,0x78040,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x478040,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x180,0x1900fd8f,0x20000000,0x8000000,0x10000000,0x6600,0x0,0x0,0x0,0x19007c00,0x0,0x0,0x0,0x20000000,0x80000000,0x19007c00,0x0,0x0,0x20000000,0x20000000,0x19007c00,0x10000000,0x0,0x20000000,0x19007c00,0x10000000,0x7c00,0x0,0x20000000,0x19007c00,0x20000000,0x8002010,0x90000000,0x90000000,0x80000000,0x80000000,0x20000000,0x20000000,0x0,0x20000000,0x19007c01,0x20000000,0x20000000,0x19007c00,0x19007c01,0x20000000,0x800f,0x6600,0x0,0x180,0x12,0x60,0x20000000,0x19007c00,0x10000000,0x19007c00,0x20000000,0x19007c00,0x20000000,0x20000000,0x8000000,0x8000000,0x8000000,0x8000000,0x7c00,0x19007c00,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x4,0x4,0x4,0x4,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x2,0x0,0x2,0x0,0x0,0x8,0x8,0x8,0x8,0x0,0x2,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[4];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  public parser(java.io.InputStream stream) {
     this(stream, null);
  }
  public parser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new parserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 66; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 66; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public parser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new parserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 66; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 66; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public parser(parserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 66; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(parserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 66; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[69];
    for (int i = 0; i < 69; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 66; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 69; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

  static final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
