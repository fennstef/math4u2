package math4u2.mathematics.standardfunctions;import math4u2.controller.Broker;import math4u2.mathematics.functions.MathException;import math4u2.mathematics.functions.MiscBinaryStandardFunction;import math4u2.mathematics.results.MatrixDoubleResult;import math4u2.mathematics.results.ScalarDoubleResult;import math4u2.mathematics.termnodes.TermNode;import math4u2.mathematics.types.ScalarType;import math4u2.mathematics.types.VectorType;/** *  * <p> * Beschreibung: Berechnet fuer zwei Vektoren v1 und v2 der Ebene (d.h. fuer * zwei Spaltenvektoren der Laenge 2) den Winkel im Intervall [0; 2*pi[, um den * man v1 drehen muss, damit er auf v2 zu liegen kommt. * </p> * <p> * Copyright: Copyright (c) 2003 * </p> * <p> * Organisation: FHA * </p> *  * @author Weiss * @version 1.0 */public class AngleFunction extends MiscBinaryStandardFunction {	public AngleFunction() {		name = "zwischenwinkel";		summaryText = "Berechnet für zwei Vektoren v1, v2 der Ebene" +				"<br>den Winkel im Intervall [0, 2*pi[, um den man" +				"<br>v1 im mathematisch positiven Sinn drehen muss," +				"<br>um die Richtung von v2 zu erhalten.";	}	public Class getResultType(Class[] argTypes) {		return ScalarType.class;	}	public Class getVariableType(int pos) throws MathException {		switch (pos) {		case 0:			return VectorType.class;		case 1:			return VectorType.class;		default:			throw new MathException("Funktion " + name					+ " hat keine Variable an der Stelle " + pos);		}	}	public Object eval(Object[] args) throws MathException {		int rowDim0 = ((MatrixDoubleResult) args[0]).rowDim;		// pruefen, ob beide Vektoren die Dimension 2 haben		if (rowDim0 != 2)			throw new MathException(					"Fehler bei Funktion winkel: erster Vektor hat nicht die Länge 2");		int rowDim1 = ((MatrixDoubleResult) args[1]).rowDim;		if (rowDim1 != 2)			throw new MathException(					"Fehler bei Funktion winkel: zweiter Vektor hat nicht die Länge 2");		// jetzt hat man zwei Vektoren der Dimension 2		double[][] v1 = ((MatrixDoubleResult) args[0]).valueArray;		double[][] v2 = ((MatrixDoubleResult) args[1]).valueArray;		// pruefen, ob einer der Vektoren der Nullvektor ist		if ((v1[0][0] == 0) && (v1[1][0] == 0))			throw new MathException(					"Fehler bei Funktion winkel: erster Vektor ist der Nullvektor");		if ((v2[0][0] == 0) && (v2[1][0] == 0))			throw new MathException(					"Fehler bei Funktion winkel: zweiter Vektor ist der Nullvektor");		// jetzt hat man zwei brauchbare Vektoren		double xk = v1[0][0] * v2[0][0] + v1[1][0] * v2[1][0];		double yk = -v1[1][0] * v2[0][0] + v1[0][0] * v2[1][0];		double result = 0;		// Es folgt eine Fallunterscheidung in insgesamt 8 Faelle		if (Math.abs(yk / xk) <= 1) {			if (yk >= 0) {				if (xk >= 0) {					result = Math.atan(yk / xk);				} else {					result = Math.atan(yk / xk) + Math.PI;				}			} // end if( yk >= 0 )			else { // yk < 0				if (xk >= 0) {					result = Math.atan(yk / xk) + 2 * Math.PI;				} else {					result = Math.atan(yk / xk) + Math.PI;				}			} // end else { // yk < 0		} else { // if( Math.abs(yk/xk) > 1 ) {			if (yk >= 0) {				result = Math.PI / 2 - Math.atan(xk / yk);			} // end if( yk >= 0 )			else { // yk < 0				result = Math.PI * 3 / 2 - Math.atan(xk / yk);			} // end else { // yk < 0		}		return new ScalarDoubleResult(result);	} //eval	public TermNode buildDeriveTerm(TermNode[] argumentTerms,			TermNode[] derivedArgumentTerms, Broker broker)			throws MathException {		throw new MathException(				"Ableitung bei Funktion winkel nicht implementiert");	}	public String[] getArgumentStrings() {		return new String[] {"v1", "v2"};	}	}//AngleFunction